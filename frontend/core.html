<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端框架核心原理 | 陈东的技术博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.9bcdb81a.css" as="style"><link rel="preload" href="/assets/js/app.65ab5bb6.js" as="script"><link rel="preload" href="/assets/js/2.de05eeee.js" as="script"><link rel="preload" href="/assets/js/7.d3f8200c.js" as="script"><link rel="prefetch" href="/assets/js/10.4a8bcf46.js"><link rel="prefetch" href="/assets/js/11.69fe1ea4.js"><link rel="prefetch" href="/assets/js/12.589a8ac0.js"><link rel="prefetch" href="/assets/js/13.ee1ca207.js"><link rel="prefetch" href="/assets/js/14.708324ab.js"><link rel="prefetch" href="/assets/js/15.79945b22.js"><link rel="prefetch" href="/assets/js/16.fa875607.js"><link rel="prefetch" href="/assets/js/17.d11e1805.js"><link rel="prefetch" href="/assets/js/18.f456e5e5.js"><link rel="prefetch" href="/assets/js/19.c0b169bb.js"><link rel="prefetch" href="/assets/js/20.3654e527.js"><link rel="prefetch" href="/assets/js/21.a2d73eda.js"><link rel="prefetch" href="/assets/js/22.e6a4b279.js"><link rel="prefetch" href="/assets/js/23.1bd22681.js"><link rel="prefetch" href="/assets/js/24.cd1bc9f3.js"><link rel="prefetch" href="/assets/js/25.9d6d1950.js"><link rel="prefetch" href="/assets/js/26.f6a5dc0c.js"><link rel="prefetch" href="/assets/js/27.f2fa6c3c.js"><link rel="prefetch" href="/assets/js/28.0a91b8c3.js"><link rel="prefetch" href="/assets/js/29.f86bb23d.js"><link rel="prefetch" href="/assets/js/3.a6f0ab89.js"><link rel="prefetch" href="/assets/js/30.3f91333f.js"><link rel="prefetch" href="/assets/js/31.f400f10b.js"><link rel="prefetch" href="/assets/js/32.05643bf3.js"><link rel="prefetch" href="/assets/js/33.08287001.js"><link rel="prefetch" href="/assets/js/34.b0cf307e.js"><link rel="prefetch" href="/assets/js/35.2f2271c1.js"><link rel="prefetch" href="/assets/js/36.b1f65533.js"><link rel="prefetch" href="/assets/js/37.fd3f295a.js"><link rel="prefetch" href="/assets/js/38.66c5ec97.js"><link rel="prefetch" href="/assets/js/39.86f7c4e3.js"><link rel="prefetch" href="/assets/js/4.cc92b40b.js"><link rel="prefetch" href="/assets/js/40.16b6d741.js"><link rel="prefetch" href="/assets/js/41.cbb53af7.js"><link rel="prefetch" href="/assets/js/5.0349abfa.js"><link rel="prefetch" href="/assets/js/6.0a12a7ac.js"><link rel="prefetch" href="/assets/js/8.1950e3c1.js"><link rel="prefetch" href="/assets/js/9.784926cb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9bcdb81a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">陈东的技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>力扣算法刷题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/leetcode/roadmap.html" class="sidebar-link">刷题路线</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>算法专题</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/leetcode/lang-diff.html" class="sidebar-link">语言差异</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/history.html" class="sidebar-link">发展史</a></li><li><a href="/frontend/core.html" aria-current="page" class="active sidebar-link">前端框架核心原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/core.html#virtualdom" class="sidebar-link">VirtualDOM</a></li><li class="sidebar-sub-header"><a href="/frontend/core.html#vdom-diff-算法" class="sidebar-link">VDOM Diff 算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/core.html#react：o-n-3-到o-n-的优化" class="sidebar-link">React：O(N^3)到O(N)的优化</a></li><li class="sidebar-sub-header"><a href="/frontend/core.html#vue：数组的编辑距离问题求解" class="sidebar-link">Vue：数组的编辑距离问题求解</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/core.html#状态管理框架" class="sidebar-link">状态管理框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/core.html#前端开发所面临的挑战" class="sidebar-link">前端开发所面临的挑战</a></li><li class="sidebar-sub-header"><a href="/frontend/core.html#redux" class="sidebar-link">Redux</a></li><li class="sidebar-sub-header"><a href="/frontend/core.html#vuex" class="sidebar-link">Vuex</a></li></ul></li></ul></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/vue/vue-setup/" class="sidebar-link">从零开始搭建Vue环境</a></li></ul></section></li><li><a href="/frontend/electron/" class="sidebar-link">Electron桌面端开发</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>后端</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/backend/cython/" class="sidebar-link">Cython入门教程</a></li><li><a href="/backend/protobuf/" class="sidebar-link">Protobuf第三方扩展开发指南</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>编程语言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/language/theory.html" class="sidebar-link">语言理论</a></li><li><a href="/language/history.html" class="sidebar-link">语言发展史</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>C</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>C++</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/language/javascript/" class="sidebar-link">JavaScript</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>专业基础四大件</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book.html" class="sidebar-link">经典书籍</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前端框架核心原理"><a href="#前端框架核心原理" class="header-anchor">#</a> 前端框架核心原理</h1> <h2 id="virtualdom"><a href="#virtualdom" class="header-anchor">#</a> VirtualDOM</h2> <p>VirtualDOM 是由 React 发扬光大的，后来 Vue 2.x 也引入了并获得非常大的性能提升。</p> <h2 id="vdom-diff-算法"><a href="#vdom-diff-算法" class="header-anchor">#</a> VDOM Diff 算法</h2> <p>因为 DOM 操作是比较耗时的，所以VDOM 发生变化后，需要根据两棵 VDOM 树之间的差异来计算：如何用<strong>最少的步骤</strong>更新 DOM 节点。</p> <p>React 将这个算法叫做 Diffing，Vue 将这个算法叫做 path。但这两个算法其实是一样的。</p> <h3 id="react：o-n-3-到o-n-的优化"><a href="#react：o-n-3-到o-n-的优化" class="header-anchor">#</a> React：O(N^3)到O(N)的优化</h3> <p>树的最小编辑距离（Tree Edit Distance）算法需要 O(N^3) 的时间复杂度，而<a href="https://zh-hans.reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener noreferrer">React官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>介绍了 React 如何根据 DOM 场景特点将该算法优化成 O(N) 的复杂度。具体来说 React 对DOM场景做了两个假设：</p> <ul><li>React 希望类型相同的兄弟节点拥有 key 信息，这就要求业务配合传入 key。这样 Diffing 算法只需根据节点的 key 信息判断是否是同一个节点，不需要遍历子孙节点</li> <li>React 假设 DOM 节点更多的是同节点下移动，很少发生跨节点移动。有了这个假设，原本树的编辑距离问题就变成了数组的编辑距离问题</li></ul> <p>这两个假设，意味着 React 求的是该问题的次优解而不是最优解，这是一种权衡。</p> <p><a href="https://github.com/supnate" target="_blank" rel="noopener noreferrer">王沛<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>做了一个<a href="https://supnate.github.io/react-dom-diff/index.html" target="_blank" rel="noopener noreferrer">在线Demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，可以在 console log 直观看到 React 在不同情况下节点创建（created）、销毁（unmount）的情况。</p> <h3 id="vue：数组的编辑距离问题求解"><a href="#vue：数组的编辑距离问题求解" class="header-anchor">#</a> Vue：数组的编辑距离问题求解</h3> <p>这个问题要求使用最少操作将旧数组变为新数组，可以进行的操作有：</p> <ul><li>创建节点</li> <li>删除节点</li> <li>移动节点</li></ul> <p>一般人可能就会遍历一遍旧节点用哈希表存起来，再遍历一遍新节点判断是否已经存在哈希表中。这样做的时间复杂度是没问题的，但是空间复杂度达到了 O(N)。</p> <p>Vue 中实现的算法虽然最坏情况下也达到了 O(N) 的空间复杂度，但 Vue 针对 DOM 场景做了一些优化，让算法在大多情况下都能达到 O(1) 的空间复杂度。如果感兴趣可以阅读以下材料：</p> <ul><li><a href="https://juejin.im/book/5a36661851882538e2259c0f" target="_blank" rel="noopener noreferrer">剖析 Vue.js 内部运行机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>Vue 源码中 <code>patch.js</code> 文件的 <code>updateChildren()</code> 函数</li></ul> <h2 id="状态管理框架"><a href="#状态管理框架" class="header-anchor">#</a> 状态管理框架</h2> <p><img src="/assets/img/store.4301e5cb.png" alt=""></p> <h3 id="前端开发所面临的挑战"><a href="#前端开发所面临的挑战" class="header-anchor">#</a> 前端开发所面临的挑战</h3> <p>随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理越来越多的 state。这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 组件的状态（如routes, tabs, spinners, pagination等等）。</p> <p>这些 state 的关系越来越错综复杂，管理它们越来越困难。直至你搞不清楚 <strong>state 在什么时候，由于什么原因，如何变化，想重现问题或者添加新功能就会变得举步维艰</strong>。前端开发者正在面临前所未有的复杂性。</p> <p>Flux, CQRS, Event Sourcing, Redux, Vuex 这些状态管理框架做的事情就是让状态改变（state mutations）变得<strong>可预测</strong>。</p> <p>参考阅读：https://redux.js.org/introduction/motivation</p> <p>同时这些框架对 state 的操作做了限制，有些限制很严格而且反常识，但遵循这些限制会带来一些开发体验的改进：</p> <ul><li>时间旅行（time travel）：可以回到过去的某个状态进行调试</li> <li>状态快照导入导出</li> <li>状态回放</li> <li>等等</li></ul> <h3 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h3> <p>Redux 借鉴了 Flux，2015年由 <a href="https://github.com/gaearon" target="_blank" rel="noopener noreferrer">Dan Abramov<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 提出。二者很像，但在具体细节上有很大区别。后来 Dan 加入了 Facebook，Redux 也就成了 Facebook 官方提供的状态管理框架。</p> <p>Redux 的三大原则：</p> <ul><li>单一数据源（Single source of truth）</li> <li>状态只可读不可写（State is read-only），state 是只读的不能直接修改，必须通过 dispatch 一个 action 进行修改</li> <li>只能通过纯函数修改状态（Changes are made with pure functions），action 会被发送给 reducer 处理，reducer 必须是纯函数</li></ul> <p>所谓纯函数就是其返回值只依赖入参，不依赖全局变量/资源的函数。</p> <p>参考阅读：https://redux.js.org/introduction/three-principles</p> <p><img src="/assets/img/redux-arch.5fec45bd.png" alt=""></p> <h4 id="action"><a href="#action" class="header-anchor">#</a> Action</h4> <p>Action 是个普通的对象，如下 <code>dispatch</code> 中的参数就是 Action：</p> <div class="language-js extra-class"><pre class="language-js"><code>store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token string">'COMPLETE_TODO'</span><span class="token punctuation">,</span>
  index<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token string">'SET_VISIBILITY_FILTER'</span><span class="token punctuation">,</span>
  filter<span class="token operator">:</span> <span class="token string">'SHOW_COMPLETED'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>action 是一个普通 JS 对象，这其实比较反常识，但这样带来的好处是可以打印在 log 上、可以被序列化、储存，甚至可以在后期调试或测试时回放出来。</p> <h4 id="reducer"><a href="#reducer" class="header-anchor">#</a> Reducer</h4> <p>Reducer 是纯函数，入参是 state 和 action，它需要返回一个新的 state。注意它不能直接修改 state 本身，哪怕只修改一个小字段也要构造并返回一个新的 state。一个简单的例子如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">todos</span><span class="token punctuation">(</span><span class="token parameter">state <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'ADD_TODO'</span><span class="token operator">:</span>
      <span class="token comment">// 注意不能就地修改state</span>
      <span class="token comment">// 不能通过 state.push({ text: action.text, completed: false }) 来实现</span>
      <span class="token keyword">return</span> <span class="token punctuation">[</span>
        <span class="token operator">...</span>state<span class="token punctuation">,</span>  <span class="token comment">// 必须拷贝一份新的</span>
        <span class="token punctuation">{</span>
          text<span class="token operator">:</span> action<span class="token punctuation">.</span>text<span class="token punctuation">,</span>
          completed<span class="token operator">:</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token keyword">case</span> <span class="token string">'COMPLETE_TODO'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">todo<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> action<span class="token punctuation">.</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> todo<span class="token punctuation">,</span> <span class="token punctuation">{</span>
            completed<span class="token operator">:</span> <span class="token boolean">true</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> todo
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们规定 Reducer 不能就地修改 state，这点非常反人类，稍微有点编程经验的人都会知道这样会使用更多的内存，加重垃圾回收器的负担。针对这点 <a href="https://github.com/reduxjs/redux/issues/328" target="_blank" rel="noopener noreferrer">Dan 做出了回应<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h3 id="vuex"><a href="#vuex" class="header-anchor">#</a> Vuex</h3> <p>TODO</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/history.html" class="prev">
        发展史
      </a></span> <span class="next"><a href="/frontend/vue/vue-setup/">
        从零开始搭建Vue环境
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.65ab5bb6.js" defer></script><script src="/assets/js/2.de05eeee.js" defer></script><script src="/assets/js/7.d3f8200c.js" defer></script>
  </body>
</html>
