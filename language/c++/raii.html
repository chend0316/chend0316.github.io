<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++内存管理 | 陈东的技术博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.9bcdb81a.css" as="style"><link rel="preload" href="/assets/js/app.bb8f2333.js" as="script"><link rel="preload" href="/assets/js/2.d2712b54.js" as="script"><link rel="preload" href="/assets/js/25.9df54eea.js" as="script"><link rel="prefetch" href="/assets/js/10.d8cada83.js"><link rel="prefetch" href="/assets/js/11.074c5603.js"><link rel="prefetch" href="/assets/js/12.62813a42.js"><link rel="prefetch" href="/assets/js/13.812ba349.js"><link rel="prefetch" href="/assets/js/14.93a81eeb.js"><link rel="prefetch" href="/assets/js/15.b056937b.js"><link rel="prefetch" href="/assets/js/16.cc58cc80.js"><link rel="prefetch" href="/assets/js/17.4c2b2a09.js"><link rel="prefetch" href="/assets/js/18.bdbd8eff.js"><link rel="prefetch" href="/assets/js/19.ee9870cd.js"><link rel="prefetch" href="/assets/js/20.e76bcecb.js"><link rel="prefetch" href="/assets/js/21.8be06af0.js"><link rel="prefetch" href="/assets/js/22.fd7cfe3c.js"><link rel="prefetch" href="/assets/js/23.0e9790d3.js"><link rel="prefetch" href="/assets/js/24.270365ac.js"><link rel="prefetch" href="/assets/js/26.f853bdd4.js"><link rel="prefetch" href="/assets/js/27.0f098a27.js"><link rel="prefetch" href="/assets/js/28.e034e19a.js"><link rel="prefetch" href="/assets/js/29.a3c02ee7.js"><link rel="prefetch" href="/assets/js/3.db2f6866.js"><link rel="prefetch" href="/assets/js/30.014cf3f8.js"><link rel="prefetch" href="/assets/js/31.164da3f6.js"><link rel="prefetch" href="/assets/js/32.b6c49651.js"><link rel="prefetch" href="/assets/js/33.39cf82e2.js"><link rel="prefetch" href="/assets/js/34.0085ad4f.js"><link rel="prefetch" href="/assets/js/35.ce32cfe9.js"><link rel="prefetch" href="/assets/js/36.08c87a94.js"><link rel="prefetch" href="/assets/js/37.961ca9b8.js"><link rel="prefetch" href="/assets/js/38.a7705435.js"><link rel="prefetch" href="/assets/js/39.95cc094d.js"><link rel="prefetch" href="/assets/js/4.9f832cf6.js"><link rel="prefetch" href="/assets/js/40.5e6bb91e.js"><link rel="prefetch" href="/assets/js/41.70b840db.js"><link rel="prefetch" href="/assets/js/42.bfc7d55b.js"><link rel="prefetch" href="/assets/js/5.d6e2f7e6.js"><link rel="prefetch" href="/assets/js/6.f3f9c8f6.js"><link rel="prefetch" href="/assets/js/7.e007dc67.js"><link rel="prefetch" href="/assets/js/8.32580c42.js"><link rel="prefetch" href="/assets/js/9.de0c5f14.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9bcdb81a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">陈东的技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/language" class="sidebar-heading clickable router-link-active open"><span>编程语言</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/language/typescript/" class="sidebar-link">TypeScript</a></li><li><a href="/language/javascript/" class="sidebar-link">JavaScript(ES5)</a></li><li><a href="/language/es6/" class="sidebar-link">JavaScript(ES6)</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>力扣算法刷题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/leetcode/roadmap.html" class="sidebar-link">刷题路线</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>算法专题</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/leetcode/lang-diff.html" class="sidebar-link">语言差异</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/history.html" class="sidebar-link">发展史</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/vue/vue-setup/" class="sidebar-link">从零开始搭建Vue环境</a></li></ul></section></li><li><a href="/frontend/electron/" class="sidebar-link">Electron桌面端开发</a></li><li><a href="/frontend/css/" class="sidebar-link">CSS</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>后端</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/backend/cython/" class="sidebar-link">Cython入门教程</a></li><li><a href="/backend/protobuf/" class="sidebar-link">Protobuf第三方扩展开发指南</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>专业基础四大件</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book.html" class="sidebar-link">经典书籍</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="c-内存管理"><a href="#c-内存管理" class="header-anchor">#</a> C++内存管理</h1> <h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <h3 id="堆（heap）"><a href="#堆（heap）" class="header-anchor">#</a> 堆（Heap）</h3> <p>在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是同一个东西，注意不要搞混。被分配之后需要手工释放，否则就会造成内存泄漏。</p> <p>C++ 标准里一个相关概念是自由存储区（free store），特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：</p> <ul><li><p><code>new</code> 和 <code>delete</code> 操作的区域是 free store</p></li> <li><p><code>malloc()</code> 和 <code>free()</code> 操作的区域是 heap</p></li></ul> <p>但 <code>new</code> 和 <code>delete</code> 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。区分二者的实际意义并不大，所以 heap 和 free store 通常混用。</p> <h3 id="栈（stack）"><a href="#栈（stack）" class="header-anchor">#</a> 栈（Stack）</h3> <p>在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈不是同一个东西，不要搞混。但它们两个还挺像的，都满足 LIFO 的特性。</p> <h3 id="raii"><a href="#raii" class="header-anchor">#</a> RAII</h3> <p>RAII (Resource Acquisition Is Initialization) 是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII。</p> <p>RAII 依托栈和析构函数，来管理所有的资源（甚至包括堆内存）。因为 RAII 的存在，所以在 C++ 中垃圾收集并不流行。</p> <h2 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h2> <p>从现代编程的角度来看，使用堆，或者说使用动态内存分配，是一件再自然不过的事情了。下面这样的代码，都会导致在堆上分配内存（并构造对象）。</p> <div class="language- extra-class"><pre class="language-text"><code>// C++
auto ptr = new std::vector&lt;int&gt;();

// Java
ArrayList&lt;int&gt; list = new ArrayList&lt;int&gt;();

# Python
lst = list()
</code></pre></div><p>从历史的角度，动态内存分配实际上是较晚出现的。由于动态内存带来的不确定性——内存分配耗时需要多久？失败了怎么办？等等——至今仍有很多场合会禁用动态内存，尤其在实时性要求比较高的场合，如飞行控制器和电信设备。不过，由于大家多半对这种用法比较熟悉，特别是从 C 和 C++ 以外的其他语言开始学习编程的程序员，所以提到内存管理，我们还是先讨论一下使用堆的编程方式。</p> <p>有些语言使用 new 这样的关键字分配内存：</p> <ul><li>C++：<code>auto list = new std::vector&lt;int&gt;();</code></li> <li>Java：<code>ArrayList&lt;int&gt; list = new ArrayList&lt;int&gt;();</code></li></ul> <p>有些语言在对象的构造时隐式分配：</p> <ul><li>Python：<code>lst = list()</code></li></ul> <p>不管是哪种语言，都会牵涉到三个可能的内存管理器的操作：</p> <ol><li><p>让内存管理器分配一个某个大小的内存块</p></li> <li><p>让内存管理器释放一个之前分配的内存块</p></li> <li><p>让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放</p></li></ol> <p>C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操作 1、2、3。这是语言的特性和实现方式决定的。</p> <p><strong>需要略加说明的是，上面的三个操作都不简单，并且彼此之间是相关的。</strong></p> <p>第一，分配内存要考虑程序当前已经有多少未分配的内存。内存不足时要从操作系统申请新的内存。内存充足时，要从可用的内存里取出一块合适大小的内存，将其标记为已用，然后将其返回。</p> <p>需要注意到，绝大部分情况下，可用内存都会比要求分配的内存大，所以代码只被允许使用其被分配的内存区域，而剩余的内存区域仍属于未分配状态，可以在后面的分配过程中使用。另外，如果内存管理器支持垃圾收集的话，分配内存的操作还可能会触发垃圾收集。</p> <p>第二，释放内存不只是简单地把内存标记为未使用。对于连续未使用的内存块，通常内存管理器需要将其合并成一块，以便可以满足后续的较大内存分配要求。毕竟，目前的编程模式都要求申请的内存块是连续的。</p> <p>第三，垃圾收集操作有很多不同的策略和实现方式，以实现性能、实时性、额外开销等各方面的平衡。这里不再展开讲解。</p> <p>下面这张图展示了一个简单的分配过程：</p> <p><img src="https://static001.geekbang.org/resource/image/18/5a/1814fb6093744c64ac9d3861fb4d3a5a.png" alt=""></p> <p><img src="https://static001.geekbang.org/resource/image/a7/3b/a7b72d6062c5cd798a2de991bffd713b.png" alt=""></p> <p>注意在图 1e 的状态下，内存管理器是满足不了长度大于 4 的内存分配要求的；而在图 1f 的状态，则长度小于等于 7 的单个内存要求都可以得到满足。</p> <p>当然，这只是一个简单的示意，只是为了让你能够对这个过程有一个大概的感性认识。在不考虑垃圾收集的情况下，内存需要手工释放；在此过程中，内存可能有碎片化的情况。比如，在图 1d 的情况下，虽然总共剩余内存为 6，但却满足不了长度大于 4 的内存分配要求。</p> <p>幸运的是，大部分软件开发人员都不需要担心这个问题。内存分配和释放的管理，是内存管理器的任务，一般情况下我们不需要介入。我们只需要正确地使用 new 和 delete。每个 new 出来的对象都应该用 delete 来释放，就是这么简单。</p> <p>但真的很简单、可以高枕无忧了吗？</p> <p>事实说明，漏掉 delete 是一种常见的情况，这叫“内存泄漏”——相信你一定听到过这个说法。为什么呢？</p> <p>我们还是看一些代码例子。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  bar<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个很简单吧，但是却存在两个问题：</p> <ul><li><p>中间省略的代码部分也许会抛出异常，导致最后的 delete ptr 得不到执行。</p></li> <li><p>更重要的，这个代码不符合 C++ 的惯用法。在 C++ 里，这种情况下有 99% 的可能性不应该使用堆内存分配，而应使用栈内存分配。这样写代码的，估计可能是从 Java 转过来的（偷笑）。</p></li></ul> <p>而更常见、也更合理的情况，是分配和释放不在一个函数里。比如下面这段示例代码：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>bar<span class="token operator">*</span> <span class="token function">make_bar</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    bar<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  bar<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">make_bar</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样的话，会漏 delete 的可能性是不是大多了？有关这个问题的解决方法，我们在下一讲还会提到。</p> <p>好，堆我们暂时就讨论到这儿。下面，我们看看更符合 C++ 特性的栈内存分配。</p> <h2 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h2> <p>本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了。我们可以看到：</p> <ul><li><p>栈上的分配极为简单，移动一下栈指针而已。</p></li> <li><p>栈上的释放也极为简单，函数执行结束时移动一下栈指针即可。</p></li></ul> <p>由于后进先出的执行过程，不可能出现内存碎片。</p> <h3 id="栈的分配和释放"><a href="#栈的分配和释放" class="header-anchor">#</a> 栈的分配和释放</h3> <p>我们先来看一段示例代码，来说明 C++ 里函数调用、本地变量是如何使用栈的。当然，这一过程取决于计算机的实际架构，具体细节可能有所不同，但原理上都是相通的，都会使用一个后进先出的结构。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码执行过程中的栈变化，我画了下面这张图来表示：</p> <p><img src="https://static001.geekbang.org/resource/image/ef/7a/ef5c5e6a1032006051e3347a24eab17a.png" alt="img"></p> <p>在我们的示例中，栈是向上增长的。在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存工作，然后会调整栈指针，<strong>分配出本地变量所需的空间</strong>，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。</p> <p>顺便说一句，图 2 中每种颜色都表示某个函数占用的栈空间。这部分空间有个特定的术语，叫做栈帧（stack frame）。GCC 和 Clang 的命令行参数中提到 frame 的，如 -fomit-frame-pointer，一般就是指栈帧。</p> <h3 id="实验：利用栈的特性访问调用函数的局部变量"><a href="#实验：利用栈的特性访问调用函数的局部变量" class="header-anchor">#</a> 实验：利用栈的特性访问调用函数的局部变量</h3> <h3 id="实验：栈展开"><a href="#实验：栈展开" class="header-anchor">#</a> 实验：栈展开</h3> <p>前面例子的本地变量是简单类型，C++ 里称之为 POD 类型（Plain Old Data）。对于有构造和析构函数的非 POD 类型，栈上的内存分配也同样有效，只不过 C++ 编译器会在生成代码的合适位置，插入对构造和析构函数的调用。</p> <p>这里尤其重要的是：编译器会自动调用析构函数，包括在函数执行发生异常的情况。在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）。事实上，如果你用 MSVC 编译含异常的 C++ 代码，但没有使用上一讲说过的 /EHsc 参数，编译器就会报告：</p> <p>warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc</p> <p>下面是一段简短的代码，可以演示栈展开：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Obj</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">&quot;Obj()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">&quot;~Obj()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  Obj obj<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token string">&quot;life, the universe and everything&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行代码的结果是：</p> <p>Obj()</p> <p>~Obj()</p> <p>Obj()</p> <p>~Obj()</p> <p>life, the universe and everything</p> <p>也就是说，不管是否发生了异常，obj 的析构函数都会得到执行。</p> <p>对堆和栈有了基本了解之后，我们继续往下，聊一聊 C++ 的重要特性 RAII。</p> <h2 id="raii-2"><a href="#raii-2" class="header-anchor">#</a> RAII</h2> <p>C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：</p> <ul><li>对象很大；</li> <li>对象的大小在编译时不能确定；</li> <li>对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。</li></ul> <p>常见情况之一是，在工厂方法或其他面向对象编程的情况下，返回值类型是基类。下面的例子，是对工厂方法的简单演示：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token class-name">class</span> shape_type <span class="token punctuation">{</span>
  circle<span class="token punctuation">,</span>
  triangle<span class="token punctuation">,</span>
  rectangle<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">shape</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">circle</span><span class="token operator">:</span> <span class="token keyword">public</span> shape <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">triangle</span><span class="token operator">:</span> <span class="token keyword">public</span> shape <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">rectangle</span><span class="token operator">:</span> <span class="token keyword">public</span> shape <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

shape<span class="token operator">*</span> <span class="token function">create_shape</span><span class="token punctuation">(</span>shape_type type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> shape_type<span class="token operator">::</span>circle<span class="token operator">:</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> shape_type<span class="token operator">::</span>triangle<span class="token operator">:</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">triangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> shape_type<span class="token operator">::</span>rectangle<span class="token operator">:</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个 create_shape 方法会返回一个 shape 对象，对象的实际类型是某个 shape 的子类，圆啊，三角形啊，矩形啊，等等。这种情况下，函数的返回值只能是指针或其变体形式。如果返回类型是 shape，实际却返回一个 circle，编译器不会报错，但结果多半是错的。这种现象叫对象切片（object slicing），是 C++ 特有的一种编码错误。这种错误不是语法错误，而是一个对象复制相关的语义错误，也算是 C++ 的一个陷阱了，大家需要小心这个问题。</p> <p>那么，我们怎样才能确保，在使用 create_shape 的返回值时不会发生内存泄漏呢？</p> <p>答案就在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。一个简单的实现如下所示：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">shape_wrapper</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">shape_wrapper</span><span class="token punctuation">(</span>shape<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token operator">~</span><span class="token function">shape_wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  shape<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
  shape<span class="token operator">*</span> ptr_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  shape_wrapper <span class="token function">ptr_wrapper</span><span class="token punctuation">(</span><span class="token function">create_shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果你好奇 delete 空指针会发生什么的话，那答案是，这是一个合法的空操作。在 new 一个对象和 delete 一个指针时编译器需要干不少活的，它们大致可以如下翻译：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// new circle()</span>
<span class="token punctuation">{</span>
  <span class="token keyword">void</span><span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>circle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    circle<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>circle<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr<span class="token operator">-&gt;</span><span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ptr<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也就是说，new 的时候先分配内存（失败时整个操作失败并向外抛出异常，通常是 bad_alloc），然后在这个结果指针上构造对象（注意上面示意中的调用构造函数并不是合法的 C++ 代码）；构造成功则 new 操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。delete 时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存。</p> <p>回到 shape_wrapper 和它的析构行为。在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：</p> <ul><li>关闭文件（fstream 的析构就会这么做）</li> <li>释放同步锁</li> <li>释放其他重要的系统资源</li></ul> <p>例如，我们应该使用：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">some_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">guard</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//  做需要同步的工作</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而不是：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">some_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//  做需要同步的工作……</span>
  <span class="token comment">//  如果发生异常或提前返回，</span>
  <span class="token comment">//  下面这句不会自动执行。</span>
  mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>顺便说一句，上面的 shape_wrapper 差不多就是个最简单的智能指针了。至于完整的智能指针，我们留到下一讲继续学习。</p> <h2 id="内容小结"><a href="#内容小结" class="header-anchor">#</a> 内容小结</h2> <p>本讲我们讨论了 C++ 里内存管理的一些基本概念，强调栈是 C++ 里最“自然”的内存使用方式，并且，使用基于栈和析构函数的 RAII，可以有效地对包括堆内存在内的系统资源进行统一管理。</p> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <p>[1] Wikipedia, “Memory management”. https://en.wikipedia.org/wiki/Memory_management</p> <p>[2] Wikipedia, “Stack-based memory allocation”. https://en.wikipedia.org/wiki/Stack-based_memory_allocation</p> <p>[3] Wikipedia, “Resource acquisition is initialization”. https://en.wikipedia.org/wiki/RAII</p> <p>[3a] 维基百科, “RAII”. https://zh.wikipedia.org/zh-cn/RAII</p> <p>[4] Wikipedia, “Call stack”. https://en.wikipedia.org/wiki/Call_stack</p> <p>[5] Wikipedia, “Object slicing”. https://en.wikipedia.org/wiki/Object_slicing</p> <p>[6] Stack Overflow, “Why does the stack address grow towards decreasing memory addresses?” https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.bb8f2333.js" defer></script><script src="/assets/js/2.d2712b54.js" defer></script><script src="/assets/js/25.9df54eea.js" defer></script>
  </body>
</html>
