(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{366:function(v,_,t){v.exports=t.p+"assets/img/es5.b9623e91.svg"},405:function(v,_,t){"use strict";t.r(_);var e=t(42),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"es5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es5"}},[v._v("#")]),v._v(" ES5")]),v._v(" "),e("p",[e("img",{attrs:{src:t(366),alt:"es5 知识体系"}})]),v._v(" "),e("h2",{attrs:{id:"原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[v._v("#")]),v._v(" 原型")]),v._v(" "),e("p",[v._v("原型链在 JS 语言规范里面叫做 "),e("code",[v._v("[[Prototype]]")]),v._v("，规范并没有要求实现这个字段。但实际上所有浏览器，甚至连 Node 服务端都实现了，而且都叫做 "),e("code",[v._v("__proto__")]),v._v("。")]),v._v(" "),e("p",[v._v("“读”操作会顺着原型链一直找，“写”操作只会写当前对象不会覆盖原型链上的对象。")]),v._v(" "),e("h3",{attrs:{id:"字段遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字段遍历"}},[v._v("#")]),v._v(" 字段遍历")]),v._v(" "),e("p",[e("code",[v._v("for...in")]),v._v(" 会将原型链上的属性一起枚举，可以配合 "),e("code",[v._v("hasOwnProperty")]),v._v(" 实现只枚举自己的属性，另外设置了 "),e("code",[v._v("enumerable:false")]),v._v(" 的属性不会被枚举。")]),v._v(" "),e("p",[v._v("除了 "),e("code",[v._v("for...in")]),v._v(" 以外的操作，例如 "),e("code",[v._v("Object.keys")]),v._v("、"),e("code",[v._v("Object.values")]),v._v("，都会忽略继承的属性。")]),v._v(" "),e("h3",{attrs:{id:"f-prototype"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#f-prototype"}},[v._v("#")]),v._v(" F.prototype")]),v._v(" "),e("p",[e("code",[v._v("F.prototype")]),v._v(" 和 "),e("code",[v._v("new")]),v._v(" 是配合使用的，他们两跟原型没啥关系，只是为了让我们能够用类似 Java 的语法来控制原型链。")]),v._v(" "),e("p",[v._v("这是 JS 语言比较坑的知识点，学习的时候要注意：")]),v._v(" "),e("ul",[e("li",[v._v("就算不用 "),e("code",[v._v("new")]),v._v(" 关键字，我们也可以实现同样的功能")]),v._v(" "),e("li",[e("code",[v._v("new")]),v._v(" 和 "),e("code",[v._v("F.prototype")]),v._v(" 是妥协的产物")])]),v._v(" "),e("h2",{attrs:{id:"函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[v._v("#")]),v._v(" 函数")]),v._v(" "),e("h3",{attrs:{id:"iife"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iife"}},[v._v("#")]),v._v(" IIFE")]),v._v(" "),e("p",[v._v("函数表达式可以立即执行，但函数声明不可以。为了让 JS 引擎能在语法上区分二者，我们有几种办法：")]),v._v(" "),e("ul",[e("li",[v._v("加括号："),e("code",[v._v("(function(){ ... })(a, b)")])]),v._v(" "),e("li",[v._v("加括号："),e("code",[v._v("(function(){ ... }(a, b))")])]),v._v(" "),e("li",[v._v("在前面加任意一元操作符："),e("code",[v._v("+function(){ ... }(a, b)")])]),v._v(" "),e("li",[v._v("这样写会识别为函数声明，导致报错："),e("code",[v._v("function(){ ... }(a, b)")])])]),v._v(" "),e("h3",{attrs:{id:"this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[v._v("#")]),v._v(" this")]),v._v(" "),e("p",[v._v("在 Java 等语言中，"),e("code",[v._v("this")]),v._v(" 的指向取决于函数定义的位置，但是在 JavaScript 中，"),e("code",[v._v("this")]),v._v(" 的指向还取决于函数调用的方式。共有 4 种调用方式：")]),v._v(" "),e("ul",[e("li",[v._v("作为函数 (function) 直接调用，这时候指向 window 对象，但开启 "),e("code",[v._v("'use strict'")]),v._v(" 之后指向 undefined")]),v._v(" "),e("li",[v._v("作为方法 (method) 调用")]),v._v(" "),e("li",[v._v("作为构造器，通过 "),e("code",[v._v("new")]),v._v(" 调用")]),v._v(" "),e("li",[v._v("通过 "),e("code",[v._v("apply")]),v._v(" 或者 "),e("code",[v._v("call")]),v._v(" 调用")])]),v._v(" "),e("p",[v._v("即便是经验丰富的工程师也会用错，所以 ES6 的箭头函数简化了 "),e("code",[v._v("this")]),v._v(" 的规则。")])])}),[],!1,null,null,null);_.default=a.exports}}]);