(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{419:function(a,t,s){"use strict";s.r(t);var v=s(45),r=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"设计模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[a._v("#")]),a._v(" 设计模式")]),a._v(" "),s("p",[a._v("comming soon...  本文正在筹备中")]),a._v(" "),s("p",[a._v("先修知识：")]),a._v(" "),s("ul",[s("li",[a._v("必须掌握一门面向对象编程语言")]),a._v(" "),s("li",[a._v("最好有一定的较大规模软件开发经验")])]),a._v(" "),s("h2",{attrs:{id:"创建型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建型"}},[a._v("#")]),a._v(" 创建型")]),a._v(" "),s("h3",{attrs:{id:"单例模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[a._v("#")]),a._v(" 单例模式")]),a._v(" "),s("h3",{attrs:{id:"工厂模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[a._v("#")]),a._v(" 工厂模式")]),a._v(" "),s("h3",{attrs:{id:"原型模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[a._v("#")]),a._v(" 原型模式")]),a._v(" "),s("p",[a._v("如果一个对象的创建非常耗费CPU时间；或者需要从外部系统、慢速IO中读取数据；或者其它难以创建的情况。那么可以考虑使用原型模式，直接从已有对象拷贝得到新对象。")]),a._v(" "),s("p",[a._v("在实践中很容易发现哪些场景需要使用原型模式，重点在于：")]),a._v(" "),s("ul",[s("li",[a._v("区分深拷贝/浅拷贝")]),a._v(" "),s("li",[a._v("语言/库是否有内置的深拷贝方法")]),a._v(" "),s("li",[a._v("深拷贝如何处理循环引用的问题")])]),a._v(" "),s("p",[a._v("如果需要手写深拷贝，那么方案有递归复制、序列化两种方法。")]),a._v(" "),s("p",[a._v("深拷贝往往很耗时，为了提升性能。一方面，我们可以结合业务，部分字段浅拷贝，部分字段深拷贝。另一方面，如果是不可变对象，可以大胆使用浅拷贝。")]),a._v(" "),s("h2",{attrs:{id:"结构型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结构型"}},[a._v("#")]),a._v(" 结构型")]),a._v(" "),s("h2",{attrs:{id:"行为型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行为型"}},[a._v("#")]),a._v(" 行为型")]),a._v(" "),s("h3",{attrs:{id:"观察者模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[a._v("#")]),a._v(" 观察者模式")]),a._v(" "),s("h2",{attrs:{id:"其它"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[a._v("#")]),a._v(" 其它")]),a._v(" "),s("h3",{attrs:{id:"mvc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[a._v("#")]),a._v(" MVC")]),a._v(" "),s("h3",{attrs:{id:"组合优于继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合优于继承"}},[a._v("#")]),a._v(" 组合优于继承")]),a._v(" "),s("p",[a._v("使用继承的话，子类会调用父类的方法，就形成了子类对父类的依赖。父类内部的实现变动，可能会影响到子类。")]),a._v(" "),s("p",[a._v("参考《Effective Java》第四章第16条")]),a._v(" "),s("h2",{attrs:{id:"附录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#附录"}},[a._v("#")]),a._v(" 附录")]),a._v(" "),s("h3",{attrs:{id:"深拷贝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[a._v("#")]),a._v(" 深拷贝")]),a._v(" "),s("p",[a._v("在原型模式中我们介绍了深拷贝，那么应该怎么实现呢？")]),a._v(" "),s("p",[a._v("在 JavaScript 中，我们可以使用 "),s("code",[a._v("JSON.parse()")]),a._v(" 和 "),s("code",[a._v("JSON.stringify()")]),a._v("，但它是有缺点的。我们还可以使用 lodash 提供的库函数 "),s("code",[a._v("_.cloneDeep()")]),a._v("。")])])}),[],!1,null,null,null);t.default=r.exports}}]);