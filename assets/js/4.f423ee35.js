(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{353:function(t,e,a){t.exports=a.p+"assets/img/0.c596b8fd.png"},354:function(t,e,a){t.exports=a.p+"assets/img/1-1.4471c396.png"},355:function(t,e,a){t.exports=a.p+"assets/img/2-1.dbac6799.png"},356:function(t,e,a){t.exports=a.p+"assets/img/2-2.f88deea9.png"},369:function(t,e,a){"use strict";a.r(e);var n=a(43),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"cython入门教程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cython入门教程"}},[t._v("#")]),t._v(" Cython入门教程")]),t._v(" "),n("p",[t._v("好好的为何要混合Python代码和C代码呢？原因主要有2个：")]),t._v(" "),n("ul",[n("li",[t._v("Python性能差，将一部分核心逻辑用C语言实现以提升整体性能")]),t._v(" "),n("li",[t._v("希望Python能够调用一个C语言实现的系统，典型例子：OpenCV计算机视觉库")])]),t._v(" "),n("p",[t._v("Python、C混合编程并不奇怪，Python官方就提供了Python/C API可以实现「用C语言编写Python库」，见"),n("a",{attrs:{href:"https://docs.python.org/3/c-api/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),n("OutboundLink")],1),t._v("，如果你点开看了你可能就会发现，这好难啊！Python/C API入门门槛太高，于是有了Cython的诞生。")]),t._v(" "),n("p",[t._v("Cython是基于Python/C API的，但学习Cython的时候完全不用了解Python/C API。\n"),n("img",{attrs:{src:a(353),alt:""}})]),t._v(" "),n("h2",{attrs:{id:"第1章-cython的安装和使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第1章-cython的安装和使用"}},[t._v("#")]),t._v(" 第1章 Cython的安装和使用")]),t._v(" "),n("h3",{attrs:{id:"_1-1-安装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-安装"}},[t._v("#")]),t._v(" 1.1 安装")]),t._v(" "),n("p",[t._v("在Linux下通过"),n("code",[t._v("pip install Cython")]),t._v("安装。安装完毕后执行"),n("code",[t._v("cython --version")]),t._v("，如果输出了版本号即安装成功。")]),t._v(" "),n("h3",{attrs:{id:"_1-2-快速入门"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-快速入门"}},[t._v("#")]),t._v(" 1.2 快速入门")]),t._v(" "),n("blockquote",[n("p",[t._v("本节完整代码见"),n("a",{attrs:{href:"https://github.com/chend0316/cython_tutorial/tree/master/ch1/1_helloworld",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("安装完成后，我们创建一个Hello World项目，需要创建"),n("code",[t._v("hello.pyx")]),t._v("和"),n("code",[t._v("setup.py")]),t._v("两个文件。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('# file: hello.pyx\ndef say_hello_to(name):\n    print("Hello %s!" % name)\n')])])]),n("div",{staticClass:"language-python extra-class"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# file: setup.py")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" distutils"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("core "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" setup\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" Cython"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Build "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" cythonize\n\nsetup"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Hello world app'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      ext_modules"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("cythonize"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello.pyx"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("p",[t._v("这样编译项目："),n("code",[t._v("python setup.py build_ext --inplace")]),t._v("，会生成"),n("code",[t._v("hello.so")]),t._v("以及一些没用的中间文件。\n下面测试我们生成的"),n("code",[t._v("hello.so")]),t._v("能不能用：")]),t._v(" "),n("div",{staticClass:"language-python extra-class"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# coding: utf-8")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 这个import会先找hello.py，找不到就会找hello.so")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" hello  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 导入了hello.so")]),t._v("\n\nhello"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("say_hello_to"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'张三'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("h3",{attrs:{id:"_1-3-cython实现python调用c库"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-cython实现python调用c库"}},[t._v("#")]),t._v(" 1.3 Cython实现Python调用C库")]),t._v(" "),n("blockquote",[n("p",[t._v("完整代码见"),n("a",{attrs:{href:"https://github.com/chend0316/cython_tutorial/tree/master/ch1/2_math",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("如果我们已经有一个C语言的动态库、静态库，如何在Python中调用外部C库呢（本节以动态库为例）？")]),t._v(" "),n("p",[t._v("现有C库如下，是一个叫做cmath的库：")]),t._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// file: cmath.c")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cmath.h"')])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// file: cmath.h")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[t._v("下面将该cmath封装为Python库，为了防止名称冲突，命名为pymath：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('# file: pymath.pyx\ncdef extern from "cmath.h":\n    int add(int a, int b)\n\ndef pyadd(int a, int b):\n    return add(a, b)\n')])])]),n("p",[t._v("然后还需要写"),n("code",[t._v("setup.py")]),t._v("，但这里不想写"),n("code",[t._v("setup.py")]),t._v("了，因为本文主要使用gcc手工编译的方式。")]),t._v(" "),n("h3",{attrs:{id:"_1-4-手工gcc编译"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-手工gcc编译"}},[t._v("#")]),t._v(" 1.4 手工gcc编译")]),t._v(" "),n("blockquote",[n("p",[t._v("本节完整代码见"),n("a",{attrs:{href:"https://github.com/chend0316/cython_tutorial/tree/master/ch1/3_gcc",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("本节介绍gcc这种比较原始的编译方式，是希望你能搞懂Cython如何运作。如果能掌握那么相信在日后的开发工作中各种编译、部署的问题都不太可能难倒你。")]),t._v(" "),n("p",[t._v("我们知道Ubuntu下Python是这样安装的："),n("code",[t._v("apt-get install python3")]),t._v("，但你可能不知道有这个东西："),n("code",[t._v("apt-get install python3-dev")]),t._v("。\n"),n("code",[t._v("python3-dev")]),t._v("这个包安装的是Python的头文件，以Ubuntu 18.04为例，安装完成后你应该可以在"),n("code",[t._v("/usr/include/python3.6/")]),t._v("找到一些头文件。")]),t._v(" "),n("p",[t._v("看图1-1可以看到3种方式的对比：")]),t._v(" "),n("ul",[n("li",[t._v("第一条线是用Python/C API，有2个哭脸，不但代码写起来烦人，编译构建也烦人，所以我们才用Cython取代Python/C API；")]),t._v(" "),n("li",[t._v("第二条线是我们最常用的setup.py，有2个笑脸，Cython项目最常用的方式；")]),t._v(" "),n("li",[t._v("第三条线有1个哭脸，也是本节要讲的，如何使用gcc这种传统的方式来编译Cython项目；")])]),t._v(" "),n("p",[n("img",{attrs:{src:a(354),alt:""}})]),t._v(" "),n("p",[t._v("主要步骤是：")]),t._v(" "),n("ul",[n("li",[t._v("使用"),n("code",[t._v("cython xxx.pyx")]),t._v("生成"),n("code",[t._v("xxx.c")])]),t._v(" "),n("li",[t._v("然后使用"),n("code",[t._v("gcc -fPIC -shared -I/usr/include/python2.7/ xxx.c -o xxx.so")]),t._v("来生成so文件")]),t._v(" "),n("li",[t._v("要注意头文件版本，自己用的是python2的头文件还是python3的头文件")])]),t._v(" "),n("h2",{attrs:{id:"第2章-cython封装c库基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第2章-cython封装c库基础"}},[t._v("#")]),t._v(" 第2章 Cython封装C库基础")]),t._v(" "),n("h3",{attrs:{id:"_2-1-在cython中调用c库函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-在cython中调用c库函数"}},[t._v("#")]),t._v(" 2.1 在Cython中调用C库函数")]),t._v(" "),n("blockquote",[n("p",[t._v("本节完整代码见"),n("a",{attrs:{href:"https://github.com/chend0316/cython_tutorial/tree/master/ch2/1_function",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("C语言有很多库函数，例如：")]),t._v(" "),n("ul",[n("li",[t._v("libc的"),n("code",[t._v("atoi")]),t._v("函数")]),t._v(" "),n("li",[t._v("math库的"),n("code",[t._v("sin")]),t._v("函数")])]),t._v(" "),n("p",[t._v("这些库函数非常常用，所以Cython已经帮我们封装了，所以我们直接调用即可。\n那么Cython到底帮我们封装了多少C库函数呢？你可以在"),n("a",{attrs:{href:"https://github.com/cython/cython/tree/master/Cython/Includes",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),n("OutboundLink")],1),t._v("找找。\n如果你需要调用的函数Cython没有封装，那么你需要自己封装，会在2.2节介绍。")]),t._v(" "),n("p",[t._v("现在我们看下Cython如何调用这些封装好的C库函数：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("# file: demo.pyx\nfrom libc.math cimport sin\nfrom libc.stdlib cimport atof\n\ndef foo(char *s):\n    x = atof(s)\n    return sin(x)\n")])])]),n("p",[t._v("测试一下可不可以用：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('# file: test.py\nimport demo\nprint(demo.foo("3.1415"))  # 答案约等于0\n')])])]),n("h3",{attrs:{id:"_2-2-实现python环境调用c库函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-实现python环境调用c库函数"}},[t._v("#")]),t._v(" 2.2 实现Python环境调用C库函数")]),t._v(" "),n("blockquote",[n("p",[t._v("本节完整代码见"),n("a",{attrs:{href:"https://github.com/chend0316/cython_tutorial/tree/master/ch2/2_wrap_function",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),n("OutboundLink")],1),t._v("。")])]),t._v(" "),n("p",[t._v("在2.1节我们已经看到Cython能够调用C函数，Cython中定义的函数能被Python调用，因此Cython就成为了Python调用C的“桥梁”，我们把这一过程叫做wrap，实现这一功能的Cython代码叫做wrapper，见图2-1。通常wrapper可以指一段代码、一个类，甚至也能泛指一类技术。")]),t._v(" "),n("p",[n("img",{attrs:{src:a(355),alt:""}})]),t._v(" "),n("p",[t._v("就和C语言开发一样，Cython代码也需要：包含头文件、链接静态库/动态库。")]),t._v(" "),n("p",[t._v("对于这几个C结构体、函数：")]),t._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// file: queue.h")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("_Queue")]),t._v(" Queue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("QueueValue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("_Queue")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tQueueEntry "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tQueueEntry "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("tail"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nQueue "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("queue_new")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("queue_free")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Queue "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("queue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[t._v("希望在Cython中调用：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('# file: queue.pyx\ncdef extern from "queue.h":  # 包含头文件\n    ctypedef struct Queue:\n        pass\n    ctypedef void *QueueValue\n\n    Queue *queue_new()\n    void queue_free(Queue *queue)\n\ndef foo():\n    # 虽然没有实际意义，但这段代码很自嗨，可以看到Cython中完全可以调用C函数\n    cdef Queue *q\n    q = queue_new()\n    queue_free(q)\n')])])]),n("p",[t._v("上面代码看出来虽然Cython可以调用C，但作为wrapper还有一个要求是将C语言自然地封装成Python风格，所以还需要下面这段代码让API更加符合面向对象：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("cdef class PyQueue:\n    cdef Queue *_c_queue\n\n    def __cinit__(self):\n        self._c_queue = queue_new()\n\n    def __dealloc__(self):\n        if self._c_queue is not NULL:\n            queue_free(self._c_queue)\n")])])]),n("p",[t._v("编译：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('# file: setup.py\nfrom distutils.core import setup, Extension\nfrom Cython.Build import cythonize\n\nextension = Extension(\n    "queue",\n    ["queue.pyx"],\n    libraries=["cqueue"]  # 在这边声明需要链接的C库（libcqueue.so）\n)\n\nsetup(\n    ext_modules=cythonize([extension])\n)\n')])])]),n("p",[t._v("这里只贴了创建、释放的封装。其它功能（如pop、push）见完整代码。")]),t._v(" "),n("h3",{attrs:{id:"_2-3-回调函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-回调函数"}},[t._v("#")]),t._v(" 2.3 回调函数")]),t._v(" "),n("blockquote",[n("p",[t._v("本节完整代码见"),n("a",{attrs:{href:"https://github.com/chend0316/cython_tutorial/tree/master/ch2/3_callback",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),n("OutboundLink")],1),t._v("。")])]),t._v(" "),n("p",[t._v("对于一些需要传入回调函数的接口，会造成调用、被调用关系的反转。在之前我们讨论的都是在Cython中调用C函数，然而回调函数使得问题变为如何让C调用Cython函数。例如现在希望封装一个这样的C函数：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("void traverse(int *arr, int len, void (*cb)(int)) {\n    for (int i = 0; i < len; i++) {\n        cb(arr[i]);\n    }\n}\n")])])]),n("p",[t._v("为了实现回调的封装：")]),t._v(" "),n("ul",[n("li",[t._v("首先需要在Cython中定义一个能被C语言调用的"),n("code",[t._v("wrap_cb")]),t._v("，这是容易的")]),t._v(" "),n("li",[t._v("然后需要在Cython的"),n("code",[t._v("wrap_cb")]),t._v("中调用Python的回调函数（我们把它叫做"),n("code",[t._v("app_cb")]),t._v("），这步会比较难实现，因为C环境调用"),n("code",[t._v("wrap_cb")]),t._v("时无法将"),n("code",[t._v("app_cb")]),t._v("的信息传入")])]),t._v(" "),n("p",[t._v("在图2-2展示的方案中，将"),n("code",[t._v("app_cb")]),t._v("存至全局变量，这样"),n("code",[t._v("wrap_cb")]),t._v("可以从全局变量取到"),n("code",[t._v("app_cb")]),t._v("。")]),t._v(" "),n("p",[n("img",{attrs:{src:a(356),alt:""}})]),t._v(" "),n("h3",{attrs:{id:"_2-4-异步回调"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-异步回调"}},[t._v("#")]),t._v(" 2.4 异步回调")]),t._v(" "),n("p",[t._v("2.3节中提到的方案不适用于异步场景，见下文专门章节分析异步场景。")]),t._v(" "),n("h3",{attrs:{id:"_2-5-结构体的封装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-结构体的封装"}},[t._v("#")]),t._v(" 2.5 结构体的封装")]),t._v(" "),n("blockquote",[n("p",[t._v("本节完整代码见"),n("a",{attrs:{href:"https://github.com/chend0316/cython_tutorial/tree/master/ch2/4_struct",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),n("OutboundLink")],1),t._v("。")])]),t._v(" "),n("h2",{attrs:{id:"第3章-pxd文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第3章-pxd文件"}},[t._v("#")]),t._v(" 第3章 pxd文件")]),t._v(" "),n("p",[t._v("就像C语言有"),n("code",[t._v(".c")]),t._v("和"),n("code",[t._v(".h")]),t._v("文件，Cython有"),n("code",[t._v(".pyx")]),t._v("和"),n("code",[t._v(".pxd")]),t._v("文件，可以帮助更好的组织、管理代码，"),n("code",[t._v("pxd")]),t._v("也可以实现wrapper的复用。")]),t._v(" "),n("h3",{attrs:{id:"_3-1-名称冲突问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-名称冲突问题"}},[t._v("#")]),t._v(" 3.1 名称冲突问题")]),t._v(" "),n("blockquote",[n("p",[t._v("本节完整代码见"),n("a",{attrs:{href:"https://github.com/chend0316/cython_tutorial/tree/master/ch3/1_pxd",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("在之前的例子中，我们把C函数的导入、Python wrapper的封装都放在了"),n("code",[t._v("pyx")]),t._v("文件中，这会导致一些符号名冲突。例如：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('cdef extern from "queue.h":\n    # 这是声明C语言中有一个名为Queue的结构体\n    ctypedef struct Queue:\n        pass\n\n# 这是提供给Python用的类，我们其实也想起名叫做Queue，但C语言结构体也叫这个名字\n# 所以我们不得不把提供给Python的类名改为PyQueue\ncdef class PyQueue:\n    cdef Queue *_c_queue\n\n    def __cinit__(self):\n        self._c_queue = ...\n')])])]),n("p",[t._v("为了解决开发中遇到的这些问题，我们可以把声明放在"),n("code",[t._v("pxd")]),t._v("中，这样就多了一层命名空间，如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('# cqueue.pxd\ncdef extern from "queue.h":\n    ctypedef struct Queue:\n        pass\n')])])]),n("p",[t._v("有了命名空间，在"),n("code",[t._v("pyx")]),t._v("中就不会产生符号名冲突了：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("# queue.pyx\ncimport cqueue\ncdef class Queue:\n    cdef cqueue.Queue *_c_queue\n\n    def __cinit__(self):\n        self._c_queue = ...\n")])])]),n("h3",{attrs:{id:"_3-2-cython代码复用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-cython代码复用"}},[t._v("#")]),t._v(" 3.2 Cython代码复用")]),t._v(" "),n("h2",{attrs:{id:"第4章-异步和内存管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第4章-异步和内存管理"}},[t._v("#")]),t._v(" 第4章 异步和内存管理")]),t._v(" "),n("p",[t._v("C程序员手动管理内存，而Python得益于垃圾回收机制，程序员无需感知内存管理。")]),t._v(" "),n("h2",{attrs:{id:"附录：cython语法参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#附录：cython语法参考"}},[t._v("#")]),t._v(" 附录：Cython语法参考")]),t._v(" "),n("p",[t._v("Cython易用的原因是它的代码跟Python几乎一样，Cython的语法是Python的「超集」，即Python代码一定是Cython代码，而Cython代码不一定是Python代码。比起Python来说，Cython多了一些跟C语言相关的语法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("# Python语法\nimport math  # 导入math.py或math.so或math目录\nfrom math import add as myadd  # Python：导入math.py中的add符号，为避免名字冲突，重命名为myadd\nmath.add(1, 2)  # 访问math中的add符号\nmyadd(1, 2)\n\n# 对应的Cython语法\ncimport math  # 导入math.pxd\nfrom math cimport add as myadd  # 导入math.pxd中的add符号，为避免名字冲突，重命名为myadd\nmath.add(1, 2)  # 访问math中的add符号\nmyadd(1, 2)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("# Python语法\ndef foo(a, b):  # 定义foo函数\n    c = 0  # 创建Python的int对象\n    c = a + b\n    return c\n\n# Cython语法\ncdef int foo(int a, int b):  # cdef是定义C语言函数，注意该函数不能被Python调用\n    cdef int c = 0  # 这是C语言的int变量\n    c = a + b\n    return c  # 返回C语言的int\n\n# Cython语法\ncpdef int foo(int a, int b):  # cpdef定义的函数可以被Python调用\n    cdef int c = 0  # C语言的int变量\n    c = a + b\n\n    # 返回的是Python的int对象\n    # Cython在这里隐式将C语言int变量转为了Python的int对象\n    # 因为变量c是基本类型，Cython帮忙转了，如果c是复杂的是不能直接return的\n    return c\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("# Python语法\nclass Person():\n    def __init__(self):  # 这是构造函数\n        pass\n\n# Cython语法\nclass Person():\n    def __init__(self):  # 和C语言相关的内存分配（如malloc）不能放在这里实现\n        pass\n\n    def __cinit__(self):  # 和C语言相关的内存分配（如malloc）要放在这里实现 \n        ... = malloc();\n\n    def __dealloc__(self):  # 和C语言相关的内存释放（如free）要放在这里实现 \n        free(...);\n")])])]),n("p",[t._v("写在最后：完整介绍Cython是一个庞大的工程，本文只是介绍了Cython的皮毛，若有疑问欢迎交流。")])])}),[],!1,null,null,null);e.default=s.exports}}]);