(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{379:function(a,n,s){"use strict";s.r(n);var t=s(42),e=Object(t.a)({},(function(){var a=this,n=a.$createElement,s=a._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"实现一个-html-解析器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现一个-html-解析器"}},[a._v("#")]),a._v(" 实现一个 HTML 解析器")]),a._v(" "),s("p",[a._v("这部分假设大家已有编译原理的基础。")]),a._v(" "),s("h2",{attrs:{id:"词法分析器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词法分析器"}},[a._v("#")]),a._v(" 词法分析器")]),a._v(" "),s("p",[a._v("token 大概长下面这样：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/f9/84/f98444aa3ea7471d2414dd7d0f5e3a84.png",alt:"img"}})]),a._v(" "),s("p",[a._v("一般是用状态机实现词法分析器，但 HTML 词法比较简单也可以用正则表达式。")]),a._v(" "),s("h3",{attrs:{id:"状态机实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态机实现"}},[a._v("#")]),a._v(" 状态机实现")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/8b/b0/8b43d598bc1f83a8a1e7e8f922013ab0.png",alt:"img"}})]),a._v(" "),s("p",[a._v("当然了，我们这里的分析比较粗略，真正完整的HTML词法状态机，比我们描述的要复杂的多。更详细的内容，你可以参考"),s("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/parsing.html#tokenization",target:"_blank",rel:"noopener noreferrer"}},[a._v("HTML官方文档"),s("OutboundLink")],1),a._v("，HTML官方文档规定了80个状态。")]),a._v(" "),s("p",[a._v("上图的状态机可以像下面这样实现：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('var data = function(c) {\n    if (c == "&") {\n        return characterReferenceInData;\n    }\n    if (c == "<") {\n        return tagOpen;\n    } else if (c == "\\0") {\n        error();\n        emitToken(c);\n        return data;\n    } else if (c==EOF) {\n        emitToken(EOF);\n        return data;\n    } else {\n        emitToken(c);\n        return data;\n    }\n};\n\nvar tagOpenState = function tagOpenState(c) {\n    if (c == "/") {\n        return endTagOpenState;\n    }\n    if (c.match(/[A-Z]/)) {\n        token = new StartTagToken();\n        token.name = c.toLowerCase();\n        return tagNameState;\n    }\n    if (c.match(/[a-z]/)) {\n        token = new StartTagToken();\n        token.name = c;\n        return tagNameState;\n    }\n    if (c=="?") {\n        return bogusCommentState;\n    } else {\n        error();\n        return dataState;\n    }\n};\n//……\n\nvar state = data;\nvar char\nwhile (char = getInput()) {\n    state = state(char);\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br"),s("span",{staticClass:"line-number"},[a._v("33")]),s("br"),s("span",{staticClass:"line-number"},[a._v("34")]),s("br"),s("span",{staticClass:"line-number"},[a._v("35")]),s("br"),s("span",{staticClass:"line-number"},[a._v("36")]),s("br"),s("span",{staticClass:"line-number"},[a._v("37")]),s("br"),s("span",{staticClass:"line-number"},[a._v("38")]),s("br"),s("span",{staticClass:"line-number"},[a._v("39")]),s("br"),s("span",{staticClass:"line-number"},[a._v("40")]),s("br"),s("span",{staticClass:"line-number"},[a._v("41")]),s("br"),s("span",{staticClass:"line-number"},[a._v("42")]),s("br"),s("span",{staticClass:"line-number"},[a._v("43")]),s("br"),s("span",{staticClass:"line-number"},[a._v("44")]),s("br"),s("span",{staticClass:"line-number"},[a._v("45")]),s("br"),s("span",{staticClass:"line-number"},[a._v("46")]),s("br"),s("span",{staticClass:"line-number"},[a._v("47")]),s("br")])]),s("h3",{attrs:{id:"正则表达式实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式实现"}},[a._v("#")]),a._v(" 正则表达式实现")]),a._v(" "),s("h2",{attrs:{id:"语法分析器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语法分析器"}},[a._v("#")]),a._v(" 语法分析器")]),a._v(" "),s("p",[a._v("接下来我们要把这些简单的词变成DOM树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，为了给你跑着玩，我们还是用JavaScript来实现吧，毕竟JavaScript中的栈只要用数组就好了。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function HTMLSyntaticalParser(){\n    var stack = [new HTMLDocument];\n    this.receiveInput = function(token) {\n        //……\n    }\n    this.getOutput = function(){\n        return stack[0];\n    }\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("p",[a._v("我们这样来设计HTML的语法分析器，receiveInput负责接收词法部分产生的词（token），通常可以由emmitToken来调用。")]),a._v(" "),s("p",[a._v("在接收的同时，即开始构建DOM树，所以我们的主要构建DOM树的算法，就写在receiveInput当中。当接收完所有输入，栈顶就是最后的根节点，我们DOM树的产出，就是这个stack的第一项。")]),a._v(" "),s("p",[a._v("为了构建DOM树，我们需要一个Node类，接下来我们所有的节点都会是这个Node类的实例。")]),a._v(" "),s("p",[a._v("在完全符合标准的浏览器中，不一样的HTML节点对应了不同的Node的子类，我们为了简化，就不完整实现这个继承体系了。我们仅仅把Node分为Element和Text（如果是基于类的OOP的话，我们还需要抽象工厂来创建对象），")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('function Element(){\n    this.childNodes = [];\n}\nfunction Text(value){\n    this.value = value || "";\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("p",[a._v("前面我们的词（token）中，以下两个是需要成对匹配的：")]),a._v(" "),s("ul",[s("li",[a._v("tag start")]),a._v(" "),s("li",[a._v("tag end")])]),a._v(" "),s("p",[a._v("根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。")]),a._v(" "),s("p",[a._v("对于Text节点，我们则需要把相邻的Text节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是Text节点，如果是的话就合并Text节点")]),a._v(" "),s("p",[a._v("同样我们来看看直观的解析过程：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('<html maaa=a >\n    <head>\n        <title>cool</title>\n    </head>\n    <body>\n        <img src="a" />\n    </body>\n</html>\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br")])]),s("p",[a._v("通过这个栈，我们可以构建DOM树：")]),a._v(" "),s("ul",[s("li",[a._v("栈顶元素就是当前节点；")]),a._v(" "),s("li",[a._v("遇到属性，就添加到当前节点；")]),a._v(" "),s("li",[a._v("遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；")]),a._v(" "),s("li",[a._v("遇到注释节点，作为当前节点的子节点；")]),a._v(" "),s("li",[a._v("遇到tag start就入栈一个节点，当前节点就是这个节点的父节点；")]),a._v(" "),s("li",[a._v("遇到tag end就出栈一个节点（还可以检查是否匹配）。")])]),a._v(" "),s("p",[a._v("我在文章里面放了一个视频，你可以点击查看用栈构造DOM树的全过程。")]),a._v(" "),s("p",[a._v("当我们的源代码完全遵循xhtml（这是一种比较严谨的HTML语法）时，这非常简单问题，然而HTML具有很强的容错能力，奥妙在于当tag end跟栈顶的start tag不匹配的时候如何处理。")]),a._v(" "),s("p",[a._v("于是，这又有一个极其复杂的规则，幸好W3C又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这个网站呈现了全部规则。你可以点击查看。")]),a._v(" "),s("p",[a._v("http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction")])])}),[],!1,null,null,null);n.default=e.exports}}]);