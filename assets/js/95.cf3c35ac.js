(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{466:function(v,a,_){"use strict";_.r(a);var t=_(42),e=Object(t.a)({},(function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),_("h2",{attrs:{id:"哈希"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哈希"}},[v._v("#")]),v._v(" 哈希")]),v._v(" "),_("p",[v._v("应用场景：")]),v._v(" "),_("ul",[_("li",[v._v("加密")]),v._v(" "),_("li",[v._v("索引")]),v._v(" "),_("li",[v._v("缓存")])]),v._v(" "),_("p",[v._v("解决哈希冲突:")]),v._v(" "),_("ul",[_("li",[v._v("开放寻址法: 线性探测法、二次探测法、再散列法")]),v._v(" "),_("li",[v._v("拉链法")])]),v._v(" "),_("p",[v._v("哈希函数的实现:")]),v._v(" "),_("ul",[_("li",[v._v("工业界著名的: MD5、SHA、CRC")]),v._v(" "),_("li",[v._v("直接定址法")]),v._v(" "),_("li",[v._v("除留余数法，要选一个较大的素数作为除数")]),v._v(" "),_("li",[v._v("一致性哈希，可以避免扩容时产生大量数据搬移")]),v._v(" "),_("li",[v._v("如果自己设计哈希算法，原则就是要尽可能随机且均匀")])]),v._v(" "),_("p",[v._v("当需要删除元素的时候，开放寻址法不能直接删除元素，而是要做特殊处理 (标记为已删除，而不是真正删除元素)。")]),v._v(" "),_("h3",{attrs:{id:"扩容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扩容"}},[v._v("#")]),v._v(" 扩容")]),v._v(" "),_("p",[v._v("当装载因子接近 1 的时候，开放寻址法速度降低。当装载因子远大于 1 时，拉链法会退化成为链表。扩容可以降低装载因子，但扩容后大量数据需要移动，这会导致分布式缓存场景下大量节点出现缓存击穿，"),_("a",{attrs:{href:"https://en.wikipedia.org/wiki/Consistent_hashing",target:"_blank",rel:"noopener noreferrer"}},[v._v("一致性哈希"),_("OutboundLink")],1),v._v("算法可以缓解这个问题。")]),v._v(" "),_("h3",{attrs:{id:"语言内置的哈希表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#语言内置的哈希表"}},[v._v("#")]),v._v(" 语言内置的哈希表")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/api/java/util/Map.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("java.util.Map"),_("OutboundLink")],1),v._v(" 是 Java 内置的一个接口，最常见的实现是："),_("code",[v._v("HashMap")]),v._v("、"),_("code",[v._v("TreeMap")]),v._v("。在 Java 中，每个对象都有 hashCode() 方法，自定义的数据类型可以根据业务特点重写 "),_("code",[v._v("Object.hashCode()")]),v._v(" 方法。")]),v._v(" "),_("p",[v._v("JavaScript 的对象本身就可以当做哈希表使用："),_("code",[v._v("var hash = {};")]),v._v("，ES6 新增了一个专门做哈希表的类："),_("code",[v._v("var hash = new Map();")])]),v._v(" "),_("p",[v._v("Python 的 "),_("code",[v._v("dict")]),v._v(" 就是哈希表。")]),v._v(" "),_("ul",[_("li",[v._v("初始化: "),_("code",[v._v("hash = dict()")])]),v._v(" "),_("li",[v._v("使用字面量初始化: "),_("code",[v._v("hash = {}")])]),v._v(" "),_("li",[v._v("添加元素: "),_("code",[v._v("hash['a'] = 123")])]),v._v(" "),_("li",[v._v("删除元素: "),_("code",[v._v("del hash['a']")])]),v._v(" "),_("li",[v._v("判断 key 是否存在: "),_("code",[v._v("'a' in hash")])]),v._v(" "),_("li",[v._v("获取哈希表的大小: "),_("code",[v._v("len(hash)")])])]),v._v(" "),_("h2",{attrs:{id:"二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[v._v("#")]),v._v(" 二叉树")]),v._v(" "),_("p",[v._v("二叉树一般用链式存储法来存储，每个节点有 left、right 两个指针。完全二叉树可以用顺序存储法来存储，常用于二叉堆的场景。")]),v._v(" "),_("h3",{attrs:{id:"二叉搜索树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树"}},[v._v("#")]),v._v(" 二叉搜索树")]),v._v(" "),_("p",[v._v("在讨论二叉搜索树时，通常是指没有重复节点的情况。删除节点操作中，如果待删节点有两个子节点就会比较复杂。还有一种取巧的删除方法，就是将节点标记为已删除，而不是真正去删除这个节点。")]),v._v(" "),_("p",[v._v("如果要支持重复数据的二叉搜索树。一种偷懒的方法是将每个节点换成链表。另一种更正经的方法不好描述，我这边先不写了。")]),v._v(" "),_("h3",{attrs:{id:"平衡二叉搜索树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉搜索树"}},[v._v("#")]),v._v(" 平衡二叉搜索树")])])}),[],!1,null,null,null);a.default=e.exports}}]);