(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{389:function(e,t,r){e.exports=r.p+"assets/img/chrome-devtool-timing.ba91f065.png"},495:function(e,t,r){"use strict";r.r(t);var a=r(45),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"前端性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化"}},[e._v("#")]),e._v(" 前端性能优化")]),e._v(" "),a("h2",{attrs:{id:"性能指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能指标"}},[e._v("#")]),e._v(" 性能指标")]),e._v(" "),a("h3",{attrs:{id:"web-vitals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-vitals"}},[e._v("#")]),e._v(" Web Vitals")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://web.dev/vitals/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Web Vitals 网站指标"),a("OutboundLink")],1)]),e._v(" "),a("ul",[a("li",[e._v("Loading: "),a("a",{attrs:{href:"https://web.dev/lcp/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LCP (Largest Contentful Paint)"),a("OutboundLink")],1),e._v(" 用于衡量网站加载速度")]),e._v(" "),a("li",[e._v("Interactivity: "),a("a",{attrs:{href:"https://web.dev/fid/",target:"_blank",rel:"noopener noreferrer"}},[e._v("FID (First Input Delay)"),a("OutboundLink")],1),e._v(" 用于衡量网站交互速度")]),e._v(" "),a("li",[e._v("Visual stability: "),a("a",{attrs:{href:"https://web.dev/cls/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CLS (Cumulative Layout Shift)"),a("OutboundLink")],1),e._v(" 用于衡量网站的视觉稳定性")]),e._v(" "),a("li",[e._v("FMP 利用工具难以自动识别，所以被 Web Vitals 弃用，取而代之的是 LCP")]),e._v(" "),a("li",[e._v("FID 测试需要一个真人参与，所以在 Chrome DevTools 里面是看不到 FID 指标的，取而代之的是 TBT (Total Blocking Time)。TBT 可以评估主线程被 block 的时间，block 期间浏览器无法响应任何用户输入，所以 TBT 能够间接量化 FID。TBT 的具体衡量算法是累加所有 JS Task 运行时长超出 50ms 的部分，如果运行了 53 ms，那么 TBT 为 3ms，如果运行了 49ms，那么 TBT 为 0ms。")])]),e._v(" "),a("p",[e._v("测量 Web Vitals 的工具:")]),e._v(" "),a("ul",[a("li",[e._v("Lighthouse")]),e._v(" "),a("li",[e._v("https://web.dev/vitals-tools/")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://developer.chrome.com/blog/new-in-devtools-84/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Chrome 84 增加了 TBT、CLS 的测量工具"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("一些性能分析/监控平台也引入了 Web Vitals:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.speedcurve.com/blog/web-vitals-user-experience/",target:"_blank",rel:"noopener noreferrer"}},[e._v("SpeedCurve"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://sentry.io/for/web-vitals/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Sentry"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("谷歌将 Web Vitals 作为搜索排序依据，所以一些内容平台为了 SEO 也引入了 Web Vitals:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://support.wix.com/en/article/site-performance-about-core-web-vitals",target:"_blank",rel:"noopener noreferrer"}},[e._v("WiX"),a("OutboundLink")],1),e._v(" 是一个 CMS 平台")]),e._v(" "),a("li",[e._v("WordPress")])]),e._v(" "),a("p",[e._v("参考资料:")]),e._v(" "),a("ul",[a("li",[e._v("https://www.youtube.com/watch?v=AQqFZ5t8uNc&list=PLNYkxOF6rcIDC0-BiwSL52yQ0n9rNozaF&index=3")]),e._v(" "),a("li",[e._v("https://www.youtube.com/watch?v=t8YBZLjL-KU&list=PLNYkxOF6rcIDC0-BiwSL52yQ0n9rNozaF&index=6")])]),e._v(" "),a("h3",{attrs:{id:"其它指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其它指标"}},[e._v("#")]),e._v(" 其它指标")]),e._v(" "),a("p",[e._v("fp fcp fmp tti")]),e._v(" "),a("p",[e._v("资源的网络请求耗时可以看下图。")]),e._v(" "),a("p",[a("img",{attrs:{src:r(389),alt:""}})]),e._v(" "),a("ul",[a("li",[e._v("Queuing 是排队等待，因为资源有优先级而且最多 6 个长连接，所以有些资源会排队等待")]),e._v(" "),a("li",[e._v("Initial connection 是建立 TCP 连接的过程")]),e._v(" "),a("li",[e._v("SSL 是 HTTPS 中的 SSL 握手过程")]),e._v(" "),a("li",[e._v("Request sent 是将数据发送出去的过程，这个过程很快")]),e._v(" "),a("li",[e._v("TTFB 是从发出数据到接收到服务器第一个字节的过程，这是衡量服务器的响应速度的重要指标")]),e._v(" "),a("li",[e._v("Content Download 是接受数据的过程，如果太慢可以考虑压缩资源大小")])]),e._v(" "),a("h2",{attrs:{id:"网络资源加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络资源加载"}},[e._v("#")]),e._v(" 网络资源加载")]),e._v(" "),a("h3",{attrs:{id:"资源加载会阻塞-dom-解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源加载会阻塞-dom-解析"}},[e._v("#")]),e._v(" 资源加载会阻塞 DOM 解析")]),e._v(" "),a("p",[e._v("因为 JS 中可能会操作 DOM，所以遇到 "),a("code",[e._v("<script>")]),e._v(" 会等 JS 加载、执行完毕后才会解析后续的 DOM。为了避免阻塞页面解析，所以我们一般将 "),a("code",[e._v("<script>")]),e._v(" 放在最后。如果 JS 里面没有操作 DOM 的代码，开发人员可以用 "),a("code",[e._v("<script async>")]),e._v(" 或 "),a("code",[e._v("<script defer>")]),e._v(" 告诉浏览器不要阻塞。async 会异步加载，一旦加载完成会立刻执行。defer 也是异步加载，会在 DOMContentLoaded 事件之前执行。")]),e._v(" "),a("p",[e._v("因为 JS 可以操作样式 "),a("code",[e._v("div1.style.color = 'red'")]),e._v("，所以说 JS 是依赖 CSS 的。所以只有 CSS 文件加载完成后，才会执行 JS，这样 JS 就会被 CSS 阻塞。从而导致 CSS 也会阻塞 DOM 解析。")]),e._v(" "),a("h3",{attrs:{id:"压缩-js-体积"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#压缩-js-体积"}},[e._v("#")]),e._v(" 压缩 JS 体积")]),e._v(" "),a("h4",{attrs:{id:"打包工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打包工具"}},[e._v("#")]),e._v(" 打包工具")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://bundlers.tooling.report/",target:"_blank",rel:"noopener noreferrer"}},[e._v("构建工具对比"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("主流的打包工具提供了体积压缩方案，但这些方案会混淆 (obfuscate) 代码，降低代码可读性、可分析性。")]),e._v(" "),a("p",[e._v("Sourcemap 提供了混淆代码与源代码的一个映射，主流浏览器都支持了 Sourcemap，在 "),a("a",{attrs:{href:"https://developer.chrome.com/docs/devtools/javascript/source-maps/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Chrome 中可以启用 Sourcemap"),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("h4",{attrs:{id:"减少-js-bundle-体积"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#减少-js-bundle-体积"}},[e._v("#")]),e._v(" 减少 JS Bundle 体积")]),e._v(" "),a("p",[e._v("减少 Bundle 体积可以优化 LCP 和 FID 指标。")]),e._v(" "),a("p",[e._v("首先要分析哪些代码占体积比较大:")]),e._v(" "),a("ul",[a("li",[e._v("使用 Chrome Network Panel 大致观察 Bundle 体积")]),e._v(" "),a("li",[e._v("使用 "),a("a",{attrs:{href:"https://developer.chrome.com/docs/devtools/coverage/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Chrome 代码覆盖率工具"),a("OutboundLink")],1),e._v(" 找哪些代码没有用到，建议配合 Sourcemap 使用")]),e._v(" "),a("li",[e._v("主流打包工具都提供了 Bundle 体积分析工具，例如 "),a("a",{attrs:{href:"https://www.npmjs.com/package/webpack-bundle-analyzer",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack-bundle-analyzer"),a("OutboundLink")],1),e._v("，可以分析 Bundle 中各个模块的体积占比")]),e._v(" "),a("li",[e._v("使用 Lighthouse 这样的集成工具")])]),e._v(" "),a("p",[e._v("然后想办法删代码或者懒加载。")]),e._v(" "),a("h4",{attrs:{id:"删除不必要的-legacy-javascript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除不必要的-legacy-javascript"}},[e._v("#")]),e._v(" 删除不必要的 Legacy JavaScript")]),e._v(" "),a("p",[e._v("目前 95% 的浏览器都是现代浏览器，没必要为它们提供 Polyfills，也没必要 transforms to legacy JS，这样代码体积更大、执行更浪费 CPU。")]),e._v(" "),a("p",[e._v("当然对于 Legacy Browser 还是要使用 Legacy JavaScript 的，所以技术重点在于:")]),e._v(" "),a("ul",[a("li",[e._v("打包的时候打两份，一份给新浏览器，一份给旧浏览器")]),e._v(" "),a("li",[e._v("Server 要区分新旧浏览器，然后发送不同版本的 JS")])]),e._v(" "),a("p",[e._v("更多资料自己谷歌搜「avoid serving legacy javascript to modern browsers」")]),e._v(" "),a("h2",{attrs:{id:"csr、ssr、同构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#csr、ssr、同构"}},[e._v("#")]),e._v(" CSR、SSR、同构")]),e._v(" "),a("p",[e._v("SSR好处：")]),e._v(" "),a("ul",[a("li",[e._v("SEO")]),e._v(" "),a("li",[e._v("性能")])]),e._v(" "),a("p",[e._v("BigPipe 是非常古老的技术，利用了 HTTP/1.1 支持分块传输的能力，在响应头中加上 "),a("code",[e._v("Transfer-Encoding: chunked")]),e._v(" 就可以告知浏览器启用该能力。")])])}),[],!1,null,null,null);t.default=v.exports}}]);