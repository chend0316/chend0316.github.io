(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{509:function(t,a,e){"use strict";e.r(a);var r=e(45),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"核心概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心概念"}},[t._v("#")]),t._v(" 核心概念")]),t._v(" "),e("h2",{attrs:{id:"基础概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础概念"}},[t._v("#")]),t._v(" 基础概念")]),t._v(" "),e("h3",{attrs:{id:"entry、output"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#entry、output"}},[t._v("#")]),t._v(" entry、output")]),t._v(" "),e("p",[t._v("略")]),t._v(" "),e("h3",{attrs:{id:"loader、plugin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#loader、plugin"}},[t._v("#")]),t._v(" loader、plugin")]),t._v(" "),e("p",[t._v("略")]),t._v(" "),e("h3",{attrs:{id:"source-map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#source-map"}},[t._v("#")]),t._v(" Source Map")]),t._v(" "),e("p",[t._v("略")]),t._v(" "),e("h3",{attrs:{id:"文件指纹"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件指纹"}},[t._v("#")]),t._v(" 文件指纹")]),t._v(" "),e("p",[t._v("文件指纹会在文件名上加一段 Hash 值，防止因为缓存机制导致浏览器使用旧的资源。")]),t._v(" "),e("h3",{attrs:{id:"配置文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置文件"}},[t._v("#")]),t._v(" 配置文件")]),t._v(" "),e("p",[t._v("要理解 Webpack 的配置文件也是 JS 文件，它会被 Node.js 执行，所以可以使用 "),e("code",[t._v("require()")]),t._v(" 导入社区第三方的包。")]),t._v(" "),e("p",[t._v("对于中大型系统，构建的需求会很复杂，这时候可以充分利用“配置文件也是 JS 代码”这一点来实现各种灵活的需求。")]),t._v(" "),e("h2",{attrs:{id:"高级概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级概念"}},[t._v("#")]),t._v(" 高级概念")]),t._v(" "),e("h3",{attrs:{id:"热更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#热更新"}},[t._v("#")]),t._v(" 热更新")]),t._v(" "),e("p",[t._v("略。")]),t._v(" "),e("h3",{attrs:{id:"webpack-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-api"}},[t._v("#")]),t._v(" Webpack API")]),t._v(" "),e("p",[t._v("我们通常是编写配置文件，然后执行 webpack 命令进行打包。而 Webpack API 是反过来的，由另一个系统调用 Webpack 进行打包，可以用于集成到现有工具链中。")]),t._v(" "),e("h3",{attrs:{id:"js-动态加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-动态加载"}},[t._v("#")]),t._v(" JS 动态加载")]),t._v(" "),e("p",[t._v("JS 动态加载可以提升首屏加载速度，也叫做按需加载、懒加载。在 CommonJS 中，可以通过 "),e("code",[t._v("require.ensure")]),t._v(" 动态加载。ES Modules 中，可以通过 "),e("code",[t._v("import('./test.js')")]),t._v(" 动态加载。")]),t._v(" "),e("p",[t._v("Webpack 会将动态加载的脚本提取到独立的文件，运行时通过 JSONP 动态加载脚本。")]),t._v(" "),e("h3",{attrs:{id:"代码分割"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码分割"}},[t._v("#")]),t._v(" 代码分割")]),t._v(" "),e("p",[t._v("如果两个文件都 import 了同一段代码，那么就会有重复的公共代码，可以使用 SplitChunksPlugin 将公共代码分离，节约体积。")]),t._v(" "),e("h3",{attrs:{id:"tree-shaking"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking"}},[t._v("#")]),t._v(" Tree Shaking")]),t._v(" "),e("p",[t._v("如果启用了 Tree Shaking，Webpack 会在编译阶段通过死码消除 (Dead code elimination) 技术，将没有用到的代码删掉，以便减小体积。")]),t._v(" "),e("p",[t._v("Tree Shaking 只支持 ES Modules，不支持 CommonJS。因为 ES Modules 是静态导入 (static import)，这有助于提升系统的自省 (introspection) 能力，帮助工具更好的进行静态代码分析。"),e("a",{attrs:{href:"https://stackoverflow.com/questions/52965907/what-is-the-meaning-of-static-import-in-es6",target:"_blank",rel:"noopener noreferrer"}},[t._v("Stack Overflow"),e("OutboundLink")],1),t._v(" 上有一个回答讲的很好。")]),t._v(" "),e("p",[t._v("Webpack 在 "),e("code",[t._v("mode = 'production'")]),t._v(" 模式下，会默认开启 Tree Shaking。")]),t._v(" "),e("h3",{attrs:{id:"scope-hoisting"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scope-hoisting"}},[t._v("#")]),t._v(" Scope Hoisting")]),t._v(" "),e("p",[t._v("Webpack 构建后的代码存在大量闭包代码，会导致：")]),t._v(" "),e("ul",[e("li",[t._v("代码体积更大")]),t._v(" "),e("li",[t._v("函数作用域变多，内存开销变大，执行速度变慢")])]),t._v(" "),e("p",[t._v("Webpack 为什么会创建那么多闭包呢？因为 Webpack 将每个 import 进来的模块包裹在 "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("IIFE"),e("OutboundLink")],1),t._v(" 里面，避免变量名冲突。")]),t._v(" "),e("p",[t._v("Scope Hoisting 是怎么减少闭包的呢？")]),t._v(" "),e("ul",[e("li",[t._v("按照模块引用顺序将模块代码放在同一个函数作用域内 (有向图的拓扑排序)")]),t._v(" "),e("li",[t._v("对变量适当重命名，防止模块之间的变量名冲突")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://webpack.js.org/configuration/mode/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Webpack 官网"),e("OutboundLink")],1),t._v("说了，在 "),e("code",[t._v("mode = 'production'")]),t._v(" 模式下，会默认开启 "),e("a",{attrs:{href:"https://webpack.js.org/plugins/module-concatenation-plugin/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ModuleConcatenationPlugin"),e("OutboundLink")],1),t._v("，这就启用了 Scope Hoisting。")]),t._v(" "),e("p",[t._v("和 Tree Shaking 一样，只支持 ES Modules，不支持 CommonJS，因为前者是 static import。")])])}),[],!1,null,null,null);a.default=s.exports}}]);