(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{398:function(e,r,t){"use strict";t.r(r);var n=t(43),o=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"刷题路线和指南"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#刷题路线和指南"}},[e._v("#")]),e._v(" 刷题路线和指南")]),e._v(" "),t("p",[e._v("注意算法学习光看、光听是远远不够的。一定要花大量时间动手去练，练完之后还需要：")]),e._v(" "),t("ul",[t("li",[e._v("能够用笔在纸上手写")]),e._v(" "),t("li",[e._v("能够跟别人讲清楚自己的思路")])]),e._v(" "),t("p",[e._v("许多人认为面试要求手写代码都是在耍流氓，这是一个非常大的误区。")]),e._v(" "),t("p",[e._v("这里列出的题目全是经典题，每一道都要反复刷。")]),e._v(" "),t("h2",{attrs:{id:"算法知识点介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法知识点介绍"}},[e._v("#")]),e._v(" 算法知识点介绍")]),e._v(" "),t("p",[e._v("搜索分为DFS、BFS，这两个算法都是有模板的，一定要把模板背下来。DFS最自然的是用递归实现，DFS改为迭代实现的意义并不大，BFS天生就是迭代实现的。在实现上，DFS会借助递归实现，BFS会借助队列实现。")]),e._v(" "),t("p",[e._v("DFS需要开辟一个集合"),t("code",[e._v("visited = set()")]),e._v("记录访问过的节点，也可以将节点修改为特殊值表示访问过，BFS天生就没有重复访问的问题。")]),e._v(" "),t("p",[e._v("DFS每轮遍历都可以知道节点的层次信息，只需要将"),t("code",[e._v("level")]),e._v("作为递归参数传入。BFS算法经过改造也可以知道层次信息，见"),t("a",{attrs:{href:"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"}},[e._v("力扣102"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("对于搜索问题，使用DFS是一种暴力算法，而剪枝是一种暴力优化。剪枝概念和代码模板都很简单，但剪枝的方法需要具体问题具体设计，深蓝下国际象棋就是将剪枝发挥到了极致。例如「N皇后问题」中，不同的剪枝策略在效率、代码优雅方面差别极大，好的剪枝策略很难被想出来。再比如「单词搜索」就需要借助Trie数据结构进行剪枝。剪枝算法的时间复杂度通常难以分析。")]),e._v(" "),t("p",[e._v("DP算法的代码模板固定，模板一定要背下来。解题分两步：定义状态空间、定义状态转移方程。只要状态空间定义的好，题目基本上就解决了一半。但状态空间往往不是那么容易想到。")]),e._v(" "),t("p",[e._v("二分查找法看似简单，但正确写出二分查找法是很不容易的。往往结合在各种问题中，如果基础不扎实，很容易写出死循环并阻碍解题思路。二分法虽然有模板，但不是很好用，因为二分法的模板不止一个，需要具体问题具体套用。有的题目要找具体的值，有的要"),t("a",{attrs:{href:"https://leetcode-cn.com/problems/sqrtx/",target:"_blank",rel:"noopener noreferrer"}},[e._v("找模糊值"),t("OutboundLink")],1),e._v("，有的要找2个值（求中位数），有的要找"),t("a",{attrs:{href:"https://leetcode-cn.com/problems/first-bad-version/",target:"_blank",rel:"noopener noreferrer"}},[e._v("命中的最左边的元素"),t("OutboundLink")],1),e._v("，也有"),t("a",{attrs:{href:"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/",target:"_blank",rel:"noopener noreferrer"}},[e._v("很难的综合题"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"基础入门"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础入门"}},[e._v("#")]),e._v(" 基础入门")]),e._v(" "),t("h3",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[e._v("#")]),e._v(" 链表")]),e._v(" "),t("p",[e._v("链表的题算法思路都比较简单，但代码实现上细节很容易出错，对代码功力的要求比较高。如果不能顺利写出来，一定要刻意练习，直到自己能在白板上手写。")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/reverse-linked-list/",target:"_blank",rel:"noopener noreferrer"}},[e._v("206. 反转链表"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/swap-nodes-in-pairs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("24. 两两交换链表中的节点"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/linked-list-cycle/",target:"_blank",rel:"noopener noreferrer"}},[e._v("141. 环形链表"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/linked-list-cycle-ii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("142. 环形链表 II"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/",target:"_blank",rel:"noopener noreferrer"}},[e._v("25. K 个一组翻转链表"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[e._v("#")]),e._v(" 数据结构")]),e._v(" "),t("h3",{attrs:{id:"堆（优先级队列）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆（优先级队列）"}},[e._v("#")]),e._v(" 堆（优先级队列）")]),e._v(" "),t("p",[e._v("堆分为大顶堆、小顶堆，需要掌握各编程语言内置的堆。此外要小心Python只支持小顶堆不支持大顶堆。")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/",target:"_blank",rel:"noopener noreferrer"}},[e._v("703. 数据流中的第K大元素"),t("OutboundLink")],1),e._v("，")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/sliding-window-maximum/",target:"_blank",rel:"noopener noreferrer"}},[e._v("239. 滑动窗口最大值"),t("OutboundLink")],1),e._v("，这题除了用大顶堆，还有一个线性时间的算法；")])]),e._v(" "),t("h3",{attrs:{id:"栈、队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈、队列"}},[e._v("#")]),e._v(" 栈、队列")]),e._v(" "),t("p",[e._v("栈和队列的题都很简单，只要掌握各个语言内置的栈、队列即可。")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/backspace-string-compare/",target:"_blank",rel:"noopener noreferrer"}},[e._v("844. 比较含退格的字符串"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/implement-stack-using-queues/",target:"_blank",rel:"noopener noreferrer"}},[e._v("225. 用队列实现栈"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/implement-queue-using-stacks/",target:"_blank",rel:"noopener noreferrer"}},[e._v("232. 用栈实现队列"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/valid-parentheses/",target:"_blank",rel:"noopener noreferrer"}},[e._v("20. 有效的括号"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[e._v("#")]),e._v(" 树")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/validate-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"}},[e._v("98. 验证二叉搜索树"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"}},[e._v("235. 二叉搜索树的最近公共祖先"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/",target:"_blank",rel:"noopener noreferrer"}},[e._v("236. 二叉树的最近公共祖先"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"trie"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#trie"}},[e._v("#")]),e._v(" Trie")]),e._v(" "),t("p",[e._v("Trie是一种新型数据结构：")]),e._v(" "),t("ul",[t("li",[e._v("多数教材中都没有提到")]),e._v(" "),t("li",[e._v("各个编程语言中也没有内置Trie")])]),e._v(" "),t("p",[e._v("由于Trie非常实用而且实现并不难，所以必须熟练到能在白板上手写这个数据结构。")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/word-search/",target:"_blank",rel:"noopener noreferrer"}},[e._v("79. 单词搜索"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/word-search-ii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("212. 单词搜索 II"),t("OutboundLink")],1),e._v("，官方题解中有基于Python字典迭代构造Trie的算法，然后用"),t("code",[e._v("$")]),e._v("字符表示单词末尾")])]),e._v(" "),t("h3",{attrs:{id:"并查集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并查集"}},[e._v("#")]),e._v(" 并查集")]),e._v(" "),t("p",[e._v("并查集也是一种新型数据结构，教材中很少提，各语言也没有内置。")]),e._v(" "),t("p",[e._v("经典并查集的实现不难，需要熟练到能在白板上手写。并查集的深度决定其优劣，所以并查集有2种优化办法：rank优化、路径压缩。")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/number-of-islands/",target:"_blank",rel:"noopener noreferrer"}},[e._v("200. 岛屿数量"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/friend-circles/",target:"_blank",rel:"noopener noreferrer"}},[e._v("547. 朋友圈"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[e._v("#")]),e._v(" 算法")]),e._v(" "),t("h3",{attrs:{id:"贪心法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪心法"}},[e._v("#")]),e._v(" 贪心法")]),e._v(" "),t("p",[e._v("对于局部最优解能推导出全局最优解的问题，可以用贪心法。但这是一个非常强的条件，能用贪心法的题目非常少。")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("122. 买卖股票的最佳时机 II"),t("OutboundLink")],1),e._v("，力扣上股票问题是一系列问题，这题的特殊性刚好能用贪心，否则通解是用DP")])]),e._v(" "),t("h3",{attrs:{id:"dfs、bfs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfs、bfs"}},[e._v("#")]),e._v(" DFS、BFS")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"}},[e._v("102. 二叉树的层序遍历"),t("OutboundLink")],1),e._v("，非常经典的面试题，除了用BFS竟然还能用DFS做")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"}},[e._v("104. 二叉树的最大深度"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"}},[e._v("111. 二叉树的最小深度"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/generate-parentheses/",target:"_blank",rel:"noopener noreferrer"}},[e._v("22. 括号生成"),t("OutboundLink")],1),e._v("，看起来不像，但其实是DFS+剪枝")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/valid-sudoku/",target:"_blank",rel:"noopener noreferrer"}},[e._v("36. 有效的数独"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/sudoku-solver/",target:"_blank",rel:"noopener noreferrer"}},[e._v("37. 解数独"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"剪枝、回溯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#剪枝、回溯"}},[e._v("#")]),e._v(" 剪枝、回溯")]),e._v(" "),t("p",[e._v("剪枝分为两种：")]),e._v(" "),t("ul",[t("li",[e._v("根据局部状态能确定答案就在某个分支，而剪去其它分支")]),e._v(" "),t("li",[e._v("根据局部状态只能确定答案最有可能在某个分支，优先遍历这个分支")])]),e._v(" "),t("p",[e._v("题目：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/n-queens/",target:"_blank",rel:"noopener noreferrer"}},[e._v("51. N皇后"),t("OutboundLink")],1),e._v("，判断是否要剪枝的逻辑可以遍历棋盘判断，或通过行列的和/差判断")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/n-queens-ii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("52. N皇后 II"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/valid-sudoku/",target:"_blank",rel:"noopener noreferrer"}},[e._v("36. 有效的数独"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/sudoku-solver/",target:"_blank",rel:"noopener noreferrer"}},[e._v("37. 解数独"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/word-search/",target:"_blank",rel:"noopener noreferrer"}},[e._v("79. 单词搜索"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/word-search-ii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("212. 单词搜索 II"),t("OutboundLink")],1),e._v("，利用Trie高效剪枝")])]),e._v(" "),t("h3",{attrs:{id:"dp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dp"}},[e._v("#")]),e._v(" DP")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/climbing-stairs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("70. 爬楼梯"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/triangle/",target:"_blank",rel:"noopener noreferrer"}},[e._v("120. 三角形最小路径和"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/maximum-product-subarray/",target:"_blank",rel:"noopener noreferrer"}},[e._v("152. 乘积最大子数组"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/",target:"_blank",rel:"noopener noreferrer"}},[e._v("121. 买卖股票的最佳时机"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("122. 买卖股票的最佳时机 II"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("123. 买卖股票的最佳时机 III"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/",target:"_blank",rel:"noopener noreferrer"}},[e._v("188. 买卖股票的最佳时机 IV"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/",target:"_blank",rel:"noopener noreferrer"}},[e._v("309. 最佳买卖股票时机含冷冻期"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/",target:"_blank",rel:"noopener noreferrer"}},[e._v("714. 买卖股票的最佳时机含手续费"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/longest-increasing-subsequence/",target:"_blank",rel:"noopener noreferrer"}},[e._v("300. 最长上升子序列"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/coin-change/",target:"_blank",rel:"noopener noreferrer"}},[e._v("322. 零钱兑换"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/edit-distance/",target:"_blank",rel:"noopener noreferrer"}},[e._v("72. 编辑距离"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"其它"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[e._v("#")]),e._v(" 其它")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/valid-anagram/",target:"_blank",rel:"noopener noreferrer"}},[e._v("242. 有效的字母异位词"),t("OutboundLink")],1),e._v("，")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/powx-n/",target:"_blank",rel:"noopener noreferrer"}},[e._v("50. Pow(x, n)"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/majority-element/",target:"_blank",rel:"noopener noreferrer"}},[e._v("169. 多数元素"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/3sum/submissions/",target:"_blank",rel:"noopener noreferrer"}},[e._v("15. 三数之和"),t("OutboundLink")],1),e._v("，这题考虑到最优复杂度比较大，所以可以先排序，然后是一道双指针的题目。这题虽然没用到高深的算法，但很难写，对算法基本功要求很高。因为这题有许多变种，所以务必认真理解本题的编程技巧，不要死背答案。")])])])}),[],!1,null,null,null);r.default=o.exports}}]);