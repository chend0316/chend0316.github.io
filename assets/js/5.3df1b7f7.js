(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{380:function(e,t,r){e.exports=r.p+"assets/img/chromium-arch.620ed7d1.png"},381:function(e,t,r){e.exports=r.p+"assets/img/electron-arch.02b605eb.png"},382:function(e,t,r){e.exports=r.p+"assets/img/chromium-electron.915b6441.png"},483:function(e,t,r){"use strict";r.r(t);var v=r(45),o=Object(v.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"electron"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#electron"}},[e._v("#")]),e._v(" Electron")]),e._v(" "),v("h2",{attrs:{id:"electron的技术架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#electron的技术架构"}},[e._v("#")]),e._v(" Electron的技术架构")]),e._v(" "),v("p",[e._v("下图是Chromium的架构图。主进程负责管理窗口、标签页、右键菜单等等，这一部分跟操作系统强相关。渲染进程负责网页的渲染，这一部分跟操作系统无关。")]),e._v(" "),v("p",[v("img",{attrs:{src:r(380),alt:""}})]),e._v(" "),v("p",[e._v("下图是Electron的架构图，可以看到他的核心工作就是把Node.js塞进去。")]),e._v(" "),v("p",[v("img",{attrs:{src:r(381),alt:""}})]),e._v(" "),v("p",[e._v("技术难点：Node.js事件循环基于libuv，但Chromium基于message bump，而一个线程在同一时间只能运行一个事件循环。")]),e._v(" "),v("p",[e._v("一开始，Electron是用libuv来实现message bump，在渲染进程中libuv实现message bump比较简单。但是在主进程内，由于各个操作系统的GUI都不一样，Mac是NSRunLoop、Linux是glib，所以工程量很大而且各种边界情况都处理不好。")]),e._v(" "),v("p",[e._v("后来libuv引入了backend_fd的概念，相当于是libuv轮询事件的文件描述符。通过轮询backend_fd可以知道libuv的一个新事件。这样就可以实现将Node.js集成到Chromium。")]),e._v(" "),v("p",[v("img",{attrs:{src:r(382),alt:""}})]),e._v(" "),v("p",[e._v("其它方案：")]),e._v(" "),v("ul",[v("li",[e._v("用一个小间隔定时器轮询GUI事件，但是这样界面响应特别慢、CPU特别高")]),e._v(" "),v("li",[e._v("让Node运行在单独的进程，通过IPC和Chromium通信，这就需要将函数参数、返回值序列化成字符串才能通过IPC传输，问题是指针/引用的地址难以序列化")])]),e._v(" "),v("h2",{attrs:{id:"electron进程间通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#electron进程间通信"}},[e._v("#")]),e._v(" Electron进程间通信")]),e._v(" "),v("p",[e._v("在Chromium架构中，我们使用"),v("code",[e._v("RenderProcess")]),e._v("和"),v("code",[e._v("RenderProcessHost")]),e._v("进行通信。而在 Electron 中，我们也有对应的 "),v("code",[e._v("ipcRenderer")]),e._v(" 和 "),v("code",[e._v("ipcMain")]),e._v("。它们都是 JS 接口，本质都是 "),v("code",[e._v("EventEmitter")]),e._v(" 实例。")]),e._v(" "),v("p",[e._v("实验代码见"),v("code",[e._v("labs/ipc")]),e._v("，实验内容包括：")]),e._v(" "),v("ul",[v("li",[e._v("创建2个BrowserWindow，这会对应2个渲染进程，可以打开任务管理器检查")]),e._v(" "),v("li",[e._v("主进程中通过global变量存储"),v("code",[e._v("webContents.id")])]),e._v(" "),v("li",[e._v("渲染进程中通过"),v("code",[e._v("remote.getGlobal()")]),e._v("接口获取global变量中的属性")]),e._v(" "),v("li",[e._v("渲染进程之间通过"),v("code",[e._v("ipcRenderer.sendTo()")]),e._v("接口进行通信")])]),e._v(" "),v("h3",{attrs:{id:"渲染进程向主进程通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程向主进程通信"}},[e._v("#")]),e._v(" 渲染进程向主进程通信")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("ipcRenderer.send()")]),e._v("和"),v("code",[e._v("ipcMain.on()")]),e._v("配合使用，无法拿到返回值")]),e._v(" "),v("li",[v("code",[e._v("ipcRenderer.invoke()")]),e._v("和"),v("code",[e._v("ipcMain.handle()")]),e._v("配合使用，可以拿到返回值")])]),e._v(" "),v("h3",{attrs:{id:"主进程向渲染进程通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主进程向渲染进程通信"}},[e._v("#")]),e._v(" 主进程向渲染进程通信")]),e._v(" "),v("ul",[v("li",[e._v("在"),v("code",[e._v("ipcMain.on(event, ...)")]),e._v("中，可以通过"),v("code",[e._v("event.reply()")])]),e._v(" "),v("li",[e._v("在"),v("code",[e._v("ipcMain.handle()")]),e._v("中，通过返回一个"),v("code",[e._v("Promise")]),e._v("对象")])]),e._v(" "),v("p",[e._v("注意主进程向渲染进程发送消息的时候，Electron需要通过"),v("code",[e._v("webContents")]),e._v("对象区分发给哪一个渲染进程，在"),v("code",[e._v("ipcMain.on(event, ...)")]),e._v("中可以通过"),v("code",[e._v("event.sender")]),e._v("拿到对应的"),v("code",[e._v("webContents")]),e._v("。通过"),v("code",[e._v("webContents.send()")]),e._v("向渲染进程发消息，为了简化Electron还提供了"),v("code",[e._v("event.reply()")]),e._v("实现同样的功能（敲更少的代码）。")]),e._v(" "),v("h3",{attrs:{id:"页面间通信-渲染进程之间通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#页面间通信-渲染进程之间通信"}},[e._v("#")]),e._v(" 页面间通信（渲染进程之间通信）")]),e._v(" "),v("ul",[v("li",[e._v("Electron 5之前，通过主进程转发")]),e._v(" "),v("li",[e._v("Electron 5之后，可以通过"),v("code",[e._v("ipcRenderer.sendTo()")])]),e._v(" "),v("li",[e._v("localStorage、sessionStorage")]),e._v(" "),v("li",[e._v("remote")])]),e._v(" "),v("h2",{attrs:{id:"额外阅读材料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#额外阅读材料"}},[e._v("#")]),e._v(" 额外阅读材料")]),e._v(" "),v("p",[e._v("架构实现：")]),e._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/34276309",target:"_blank",rel:"noopener noreferrer"}},[e._v("【译】探索NW.js和Electron的内部(一)"),v("OutboundLink")],1)]),e._v(" "),v("li",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/34336363",target:"_blank",rel:"noopener noreferrer"}},[e._v("【译】探索NW.js和Electron的内部(二)"),v("OutboundLink")],1)]),e._v(" "),v("li",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/34404999",target:"_blank",rel:"noopener noreferrer"}},[e._v("【译】探索NW.js和Electron的内部(三)"),v("OutboundLink")],1)]),e._v(" "),v("li",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/34544004",target:"_blank",rel:"noopener noreferrer"}},[e._v("【译+源码分析】Electron内部：整合 Message Loop"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=o.exports}}]);