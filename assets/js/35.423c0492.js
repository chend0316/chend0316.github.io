(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{419:function(t,a,s){"use strict";s.r(a);var r=s(45),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),s("p",[t._v("textbook")]),t._v(" "),s("ol",[s("li",[t._v("《Algorithm Design》建议读英文版")]),t._v(" "),s("li",[t._v("《算法导论》")])]),t._v(" "),s("p",[t._v("教程推荐学堂在线的「算法设计与分析」，这门课")]),t._v(" "),s("ul",[s("li",[t._v("思路十分清晰")]),t._v(" "),s("li",[t._v("没有半句废话，视频很快就可以看完")]),t._v(" "),s("li",[t._v("和《Algorithm Design》内容一致，配合使用效果绝佳")])]),t._v(" "),s("h2",{attrs:{id:"时间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[t._v("#")]),t._v(" 时间复杂度")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.bigocheatsheet.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("big O cheat sheet"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"graphs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#graphs"}},[t._v("#")]),t._v(" Graphs")]),t._v(" "),s("p",[t._v("图是由 node (节点) 和 edge (边) 组成的集合，一般记作 G=(V,E)。")]),t._v(" "),s("ul",[s("li",[t._v("V = nodes")]),t._v(" "),s("li",[t._v("E = edges")]),t._v(" "),s("li",[t._v("一般用 n 表示节点个数，m 表示边的个数，即: "),s("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[s("mjx-math",{staticClass:" MJX-TEX"},[s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"n"}})],1),s("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[s("mjx-c",{attrs:{c:"="}})],1),s("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[s("mjx-c",{attrs:{c:"|"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"V"}})],1),s("mjx-mo",{staticClass:"mjx-n"},[s("mjx-c",{attrs:{c:"|"}})],1),s("mjx-mo",{staticClass:"mjx-n"},[s("mjx-c",{attrs:{c:","}})],1),s("mjx-mi",{staticClass:"mjx-i",attrs:{space:"2"}},[s("mjx-c",{attrs:{c:"m"}})],1),s("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[s("mjx-c",{attrs:{c:"="}})],1),s("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[s("mjx-c",{attrs:{c:"|"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"E"}})],1),s("mjx-mo",{staticClass:"mjx-n"},[s("mjx-c",{attrs:{c:"|"}})],1)],1)],1)],1)]),t._v(" "),s("p",[t._v("图的表示: Adjacency Matrix (邻接矩阵)、Adjancency List (邻接表)。一般而言前者适合稠密图，后者适合稀疏图。")]),t._v(" "),s("h2",{attrs:{id:"network-flow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#network-flow"}},[t._v("#")]),t._v(" Network Flow")]),t._v(" "),s("p",[t._v("在 Graph 上进行贪心无法得到正确答案，但在 Residual Graph 上进行贪心可以，这就是 Ford-Fulkerson 算法的思想。")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm",target:"_blank",rel:"noopener noreferrer"}},[t._v("Ford–Fulkerson 算法"),s("OutboundLink")],1),t._v(" 没有规定寻找 augmenting path 的具体方法，所以只是一个算法思想。选取 augmenting path 的方法有很多：")]),t._v(" "),s("ul",[s("li",[t._v("Ford–Fulkerson 算法，随便选一个 augmenting path")]),t._v(" "),s("li",[t._v("Edmonds-Karp 算法，EK 算法用 BFS 优先选一条最短的 augmenting path")]),t._v(" "),s("li",[t._v("《Algorithm Design》介绍了一种约束 bottleneck 的算法")]),t._v(" "),s("li",[t._v("Dinic 算法")]),t._v(" "),s("li",[t._v("MPM 算法")])]),t._v(" "),s("p",[t._v("More Topics")]),t._v(" "),s("ul",[s("li",[t._v("二分图匹配问题")]),t._v(" "),s("li",[t._v("最小费用流")])])])}),[],!1,null,null,null);a.default=e.exports}}]);