(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{391:function(e,s,a){"use strict";a.r(s);var v=a(42),t=Object(v.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[e._v("#")]),e._v(" 数据库")]),e._v(" "),a("h2",{attrs:{id:"键值数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#键值数据库"}},[e._v("#")]),e._v(" 键值数据库")]),e._v(" "),a("p",[e._v("【存什么数据】键值数据库中，数据一定是以 Key-Value 的形式存储的，Key 一定是 String 类型，而 Value 不一定。")]),e._v(" "),a("ul",[a("li",[e._v("Redis 的 Value 可以是 String、哈希表、列表、集合等类型")]),e._v(" "),a("li",[e._v("Memcached 的 Value 只能是 String 类型")])]),e._v(" "),a("p",[e._v("【存在哪里】数据可以存在内存或外存中。")]),e._v(" "),a("ul",[a("li",[e._v("Redis、Memcached 都是放在内存里面；速度很快，但数据有丢失风险；适用于缓存等数据丢失不敏感场景；")]),e._v(" "),a("li",[e._v("放在外存里面")]),e._v(" "),a("li",[e._v("另一种方案是购买非易失性内存")])]),e._v(" "),a("p",[e._v("【如何访问】单机型数据库还是联机型数据库？")]),e._v(" "),a("ul",[a("li",[e._v("RocksDB 是单机型数据库，提供动态库文件给业务访问")]),e._v(" "),a("li",[e._v("Memcached 和 Redis 是联机型数据库，通过网络协议来访问")])]),e._v(" "),a("p",[e._v("【如何根据 key 找到 value】这就涉及到索引的概念，索引的常见实现包括哈希表、B+树、跳表、字典树。")]),e._v(" "),a("ul",[a("li",[e._v("Redis、Memcached 采用哈希表")]),e._v(" "),a("li",[e._v("RocksDB 采用跳表")])]),e._v(" "),a("h3",{attrs:{id:"redis-的-kv-映射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-的-kv-映射"}},[e._v("#")]),e._v(" Redis 的 KV 映射")]),e._v(" "),a("p",[e._v("Redis 使用哈希表，使用拉链法解决哈希冲突。")]),e._v(" "),a("p",[e._v("【rehash】拉链法中的链表过长，会导致性能/吞吐量下降。为了解决这个问题，Redis 使用了 rehash 的机制。内部有 hash1 和 hash2 两个哈希表，当 hash1 的链表过长时，为 hash2 分配两倍的空间，同时将 hash1 的数据拷贝到 hash2。通过两个哈希表轮换使用，实现了哈希表的扩容，减少冲突/减少链表长度。")]),e._v(" "),a("p",[e._v("【渐进式rehash】rehash 涉及到哈希表的整体复制，会导致线程阻塞/单次响应时间长。为了解决这个问题，Redis 采用"),a("a",{attrs:{href:""}},[e._v("渐进式 rehash")]),e._v(" 机制，将大量数据拷贝操作分摊到每次请求中。")]),e._v(" "),a("h3",{attrs:{id:"redis-的单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-的单线程"}},[e._v("#")]),e._v(" Redis 的单线程")]),e._v(" "),a("p",[e._v("我们平时说 Redis 单线程，指的是其网络 I/O 和数据读写操作是放在同一个线程里面的。通过多路复用，保证单线程下也能实现高吞吐量。")]),e._v(" "),a("p",[e._v("其内部是基于非阻塞式 Socket + select/epoll 实现的。")])])}),[],!1,null,null,null);s.default=t.exports}}]);