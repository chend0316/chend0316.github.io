(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{472:function(t,a,e){"use strict";e.r(a);var r=e(45),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"前端基础功"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端基础功"}},[t._v("#")]),t._v(" 前端基础功")]),t._v(" "),e("h2",{attrs:{id:"使用-javascript-编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-javascript-编程"}},[t._v("#")]),t._v(" 使用 JavaScript 编程")]),t._v(" "),e("p",[t._v("JavaScript 语言我认为是基础中的基础，所以移动到"),e("a",{attrs:{href:"/programmer/language/javascript"}},[t._v("程序员基本功-编程语言")]),t._v("里面了。有许多 JavaScript 语言扩展，最成功的自然是 "),e("a",{attrs:{href:"./jsx"}},[t._v("JSX")]),t._v("、TypeScript，还有一些如 CoffeeScript 早已被淘汰。")]),t._v(" "),e("p",[e("a",{attrs:{href:"./data-fetch"}},[t._v("数据获取")]),t._v("会介绍：Ajax/Fetch、跨域。")]),t._v(" "),e("p",[e("a",{attrs:{href:"./data-store"}},[t._v("数据存储")]),t._v("会介绍：Cookie、Web Storage。")]),t._v(" "),e("p",[e("a",{attrs:{href:"./control-flow"}},[t._v("程序控制流")]),t._v("会介绍：Promise、Observable (RxJS)。")]),t._v(" "),e("p",[e("a",{attrs:{href:"./dom-event"}},[t._v("DOM 事件")]),t._v("会介绍：事件冒泡、节流、防抖、事件代理/委托等内容。")]),t._v(" "),e("h2",{attrs:{id:"web-安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web-安全"}},[t._v("#")]),t._v(" Web 安全")]),t._v(" "),e("p",[t._v("会介绍 XSS、CSRF、Cookie 相关的网络安全攻防知识。")]),t._v(" "),e("h2",{attrs:{id:"浏览器原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理"}},[t._v("#")]),t._v(" 浏览器原理")]),t._v(" "),e("p",[e("a",{attrs:{href:"./event-loop"}},[t._v("事件循环系统")]),t._v("必须要充分理解，这是异步编程的基石，它的本质就是个死循环，我甚至建议大家用 C 语言自己实现一个事件循环。基础打好之后才能理解单线程异步编程的一些奇怪的现象：")]),t._v(" "),e("ul",[e("li",[t._v("setTimeout 为何不准？")]),t._v(" "),e("li",[t._v("为啥宏任务比微任务要慢？")])]),t._v(" "),e("p",[t._v("理解 "),e("a",{attrs:{href:"./v8-engine"}},[t._v("V8 引擎")]),t._v("对实际业务开发似乎确实没太大有帮助，但我还是觉得应该去了解了解。")]),t._v(" "),e("h2",{attrs:{id:"css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[t._v("#")]),t._v(" CSS")]),t._v(" "),e("h3",{attrs:{id:"盒模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#盒模型"}},[t._v("#")]),t._v(" 盒模型")]),t._v(" "),e("h3",{attrs:{id:"布局-排版"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#布局-排版"}},[t._v("#")]),t._v(" 布局/排版")]),t._v(" "),e("p",[t._v("CSS 2.1 第九章和第十章介绍了视觉格式化模型 (Visual formatting model)。9.2 节介绍了如何产生 block container box、Block-level box、Inline-level box。")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context",target:"_blank",rel:"noopener noreferrer"}},[t._v("有些情况"),e("OutboundLink")],1),t._v("会创建 BFC，BFC 减轻了排版引擎的负担，因为 BFC 内部的排版逻辑可以独立计算，相当于一个独立的小世界，不受其它元素影响:")]),t._v(" "),e("ul",[e("li",[t._v("同一个 BFC 内会有外边距折叠，BFC 之间不会有外边距折叠")]),t._v(" "),e("li",[t._v("BFC 内的 Line Box 不会受到其它 BFC 内的 Float 元素的影响")])]),t._v(" "),e("p",[t._v("以上排版计算完成后，CSS Transforms Module Level 1 规定的平移、旋转、缩放还能进一步改变元素在坐标系中的位置。")]),t._v(" "),e("p",[t._v("CSSOM View 中定义的 "),e("code",[t._v("getClientRects()")]),t._v(" 和 "),e("code",[t._v("getBoundingClientRect()")]),t._v(" 可以用于获取元素排版之后的尺寸和位置信息。")])])}),[],!1,null,null,null);a.default=v.exports}}]);