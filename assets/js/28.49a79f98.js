(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{389:function(t,v,_){"use strict";_.r(v);var a=_(42),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"js-引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js-引擎"}},[t._v("#")]),t._v(" JS 引擎")]),t._v(" "),_("h2",{attrs:{id:"v8-垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-垃圾回收"}},[t._v("#")]),t._v(" V8 垃圾回收")]),t._v(" "),_("p",[t._v("JavaScript 原始类型数据存放在栈中，通过移动栈顶指针 ESP 实现变量销毁，天生不需要垃圾回收。对象类型数据以及闭包空间中的数据存放在堆中，堆中的数据需要垃圾回收。")]),t._v(" "),_("p",[t._v("代际假说 (The Generational Hypothesis) 表明一个对象的生命周期要么很短要么很长。因此 V8 引擎实现了两种不同的垃圾回收器。")]),t._v(" "),_("ul",[_("li",[t._v("副垃圾回收器负责回收新生代对象")]),t._v(" "),_("li",[t._v("主垃圾回收器负责回收老生代对象")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th"),t._v(" "),_("th",[t._v("生命周期")]),t._v(" "),_("th",[t._v("体积大小")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("新生代对象")]),t._v(" "),_("td",[t._v("短")]),t._v(" "),_("td",[t._v("小")])]),t._v(" "),_("tr",[_("td",[t._v("老生代对象")]),t._v(" "),_("td",[t._v("长")]),t._v(" "),_("td",[t._v("大")])])])]),t._v(" "),_("p",[t._v("垃圾回收器执行流程：")]),t._v(" "),_("ol",[_("li",[t._v("标记非活动对象")]),t._v(" "),_("li",[t._v("回收非活动对象的内存")]),t._v(" "),_("li",[t._v("进行内存碎片整理")])]),t._v(" "),_("p",[t._v("V8 副垃圾回收器采用 Scavenge 算法将新生区内存分为对象区域和空闲区域，两个区域轮换使用。轮换时将一个区域的活动对象复制到另一个区域，天生不会产生内存碎片。由于新生代对象体积小，所以也不会浪费太多内存。")]),t._v(" "),_("p",[t._v("主垃圾回收器采用 Mark-Sweep 算法。由于会产生内存碎片，因此派生出了 Mark-Compact 算法。由于老生区空间很大，一次完整回收会卡顿很久，因此派生出了 Incremental Marking 算法。")]),t._v(" "),_("p",[t._v("JavaScript 中分配的大对象会直接存放在老生区。小对象会先放在新生区，如果经历了两次垃圾回收还存活则会被移动到老生区，这个过程叫做对象晋升。")]),t._v(" "),_("h2",{attrs:{id:"v8-编译器-解释器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-编译器-解释器"}},[t._v("#")]),t._v(" V8 编译器/解释器")])])}),[],!1,null,null,null);v.default=e.exports}}]);