(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{418:function(a,v,_){"use strict";_.r(v);var t=_(45),e=Object(t.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[a._v("#")]),a._v(" 数据结构")]),a._v(" "),_("h2",{attrs:{id:"线性结构-队列、栈、链表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线性结构-队列、栈、链表"}},[a._v("#")]),a._v(" 线性结构: 队列、栈、链表")]),a._v(" "),_("ul",[_("li",[a._v("队列 (Queue)")]),a._v(" "),_("li",[a._v("栈 (Stack)")]),a._v(" "),_("li",[a._v("链表 (List)")])]),a._v(" "),_("h2",{attrs:{id:"哈希表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哈希表"}},[a._v("#")]),a._v(" 哈希表")]),a._v(" "),_("p",[a._v("哈希表 (Hash Table)")]),a._v(" "),_("ul",[_("li",[a._v("英文语境也会叫做: map、dict、kv-pair")]),a._v(" "),_("li",[a._v("中文语境也会叫做: 映射、字典、键值对")])]),a._v(" "),_("p",[a._v("应用场景：")]),a._v(" "),_("ul",[_("li",[a._v("加密")]),a._v(" "),_("li",[a._v("索引")]),a._v(" "),_("li",[a._v("缓存")])]),a._v(" "),_("p",[a._v("解决哈希冲突:")]),a._v(" "),_("ul",[_("li",[a._v("开放寻址法: 线性探测法、二次探测法、再散列法")]),a._v(" "),_("li",[a._v("拉链法")])]),a._v(" "),_("p",[a._v("哈希函数的实现:")]),a._v(" "),_("ul",[_("li",[a._v("工业界著名的: MD5、SHA、CRC")]),a._v(" "),_("li",[a._v("直接定址法")]),a._v(" "),_("li",[a._v("除留余数法，要选一个较大的素数作为除数")]),a._v(" "),_("li",[a._v("一致性哈希，可以避免扩容时产生大量数据搬移")]),a._v(" "),_("li",[a._v("如果自己设计哈希算法，原则就是要尽可能随机且均匀")])]),a._v(" "),_("p",[a._v("当需要删除元素的时候，开放寻址法不能直接删除元素，而是要做特殊处理 (标记为已删除，而不是真正删除元素)。")]),a._v(" "),_("h3",{attrs:{id:"扩容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扩容"}},[a._v("#")]),a._v(" 扩容")]),a._v(" "),_("p",[a._v("当装载因子接近 1 的时候，开放寻址法速度降低。当装载因子远大于 1 时，拉链法会退化成为链表。扩容可以降低装载因子，但扩容后大量数据需要移动，这会导致分布式缓存场景下大量节点出现缓存击穿，"),_("a",{attrs:{href:"https://en.wikipedia.org/wiki/Consistent_hashing",target:"_blank",rel:"noopener noreferrer"}},[a._v("一致性哈希"),_("OutboundLink")],1),a._v("算法可以缓解这个问题。")]),a._v(" "),_("h3",{attrs:{id:"编程语言内置的哈希表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编程语言内置的哈希表"}},[a._v("#")]),a._v(" 编程语言内置的哈希表")]),a._v(" "),_("p",[_("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/api/java/util/Map.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("java.util.Map"),_("OutboundLink")],1),a._v(" 是 Java 内置的一个接口，最常见的实现是："),_("code",[a._v("HashMap")]),a._v("、"),_("code",[a._v("TreeMap")]),a._v("。在 Java 中，每个对象都有 hashCode() 方法。")]),a._v(" "),_("p",[a._v("JavaScript 的对象本身就可以当做哈希表使用："),_("code",[a._v("var hash = {};")]),a._v("，ES6 新增了一个专门做哈希表的类："),_("code",[a._v("var hash = new Map();")])]),a._v(" "),_("p",[a._v("Python 的 "),_("code",[a._v("dict")]),a._v(" 就是哈希表。")]),a._v(" "),_("ul",[_("li",[a._v("初始化: "),_("code",[a._v("hash = dict()")])]),a._v(" "),_("li",[a._v("使用字面量初始化: "),_("code",[a._v("hash = {}")])]),a._v(" "),_("li",[a._v("添加元素: "),_("code",[a._v("hash['a'] = 123")])]),a._v(" "),_("li",[a._v("删除元素: "),_("code",[a._v("del hash['a']")])]),a._v(" "),_("li",[a._v("判断 key 是否存在: "),_("code",[a._v("'a' in hash")])]),a._v(" "),_("li",[a._v("获取哈希表的大小: "),_("code",[a._v("len(hash)")])])]),a._v(" "),_("h2",{attrs:{id:"半线性结构-二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#半线性结构-二叉树"}},[a._v("#")]),a._v(" 半线性结构: 二叉树")]),a._v(" "),_("p",[a._v("二叉树一般用链式存储法来存储，每个节点有 left、right 两个指针。完全二叉树可以用顺序存储法来存储，常用于二叉堆的场景。")]),a._v(" "),_("h3",{attrs:{id:"二叉搜索树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树"}},[a._v("#")]),a._v(" 二叉搜索树")]),a._v(" "),_("p",[a._v("在讨论二叉搜索树时，通常是指没有重复节点的情况。删除节点操作中，如果待删节点有两个子节点就会比较复杂。还有一种取巧的删除方法，就是将节点标记为已删除，而不是真正去删除这个节点。")]),a._v(" "),_("p",[a._v("如果要支持重复数据的二叉搜索树。一种偷懒的方法是将每个节点换成链表。另一种更正经的方法不好描述，我这边先不写了。")]),a._v(" "),_("h3",{attrs:{id:"平衡二叉搜索树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉搜索树"}},[a._v("#")]),a._v(" 平衡二叉搜索树")]),a._v(" "),_("h2",{attrs:{id:"非线性结构-图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非线性结构-图"}},[a._v("#")]),a._v(" 非线性结构: 图")])])}),[],!1,null,null,null);v.default=e.exports}}]);