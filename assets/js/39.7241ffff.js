(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{399:function(e,t,a){"use strict";a.r(t);var r=a(43),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"滑动窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[e._v("#")]),e._v(" 滑动窗口")]),e._v(" "),a("p",[e._v("滑动窗口和双指针一样，都是对暴力算法的优化，少枚举了很多区间。它在迭代的过程中维护L、R两个指针，每次迭代只会移动L或者R。")]),e._v(" "),a("p",[e._v("什么样的问题可以用滑动窗口来解决？")]),e._v(" "),a("ul",[a("li",[e._v("新问题可在原问题的基础上“增量”计算得到")]),e._v(" "),a("li",[e._v("可以根据当前问题的状态判断下一问题是移动L指针还是R指针（决策单调性）")])]),e._v(" "),a("p",[e._v("为什么滑动窗口算法是正确的？对理论感兴趣的同学可以查阅「决策单调性」相关的资料。")]),e._v(" "),a("h2",{attrs:{id:"leetcode-3-无重复字符的最长子串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-3-无重复字符的最长子串"}},[e._v("#")]),e._v(" LeetCode 3. 无重复字符的最长子串")]),e._v(" "),a("h2",{attrs:{id:"leetcode-76-最小覆盖子串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-76-最小覆盖子串"}},[e._v("#")]),e._v(" LeetCode 76. 最小覆盖子串")]),e._v(" "),a("h2",{attrs:{id:"leetcode-209-长度最小的子数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-209-长度最小的子数组"}},[e._v("#")]),e._v(" LeetCode 209. 长度最小的子数组")]),e._v(" "),a("p",[e._v("注意循环终止条件的设定，过早终止循环会漏解。\n注意窗口区间语义约定，左闭右开or左闭右闭？虽然左闭右开有良好的语义（两数相减刚好为窗口长度），但左闭右开需要不断判断右边界是否越界常数时间更大。")]),e._v(" "),a("h2",{attrs:{id:"leetcode-424-替换后的最长重复字符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-424-替换后的最长重复字符"}},[e._v("#")]),e._v(" LeetCode 424. 替换后的最长重复字符")]),e._v(" "),a("h2",{attrs:{id:"leetcode-438-找到字符串中所有字母异位词"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-438-找到字符串中所有字母异位词"}},[e._v("#")]),e._v(" LeetCode 438. 找到字符串中所有字母异位词")]),e._v(" "),a("h2",{attrs:{id:"leetcode-567-字符串的排列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-567-字符串的排列"}},[e._v("#")]),e._v(" LeetCode 567. 字符串的排列")])])}),[],!1,null,null,null);t.default=s.exports}}]);