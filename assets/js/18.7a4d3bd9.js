(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{378:function(v,_,t){"use strict";t.r(_);var l=t(42),r=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"后端概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后端概述"}},[v._v("#")]),v._v(" 后端概述")]),v._v(" "),t("h2",{attrs:{id:"rpc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rpc"}},[v._v("#")]),v._v(" RPC")]),v._v(" "),t("p",[v._v("RPC 就是让业务像调用本地函数一样去使用远程计算机提供的服务。发起 RPC 调用请求的那一方叫做调用方，被调用的一方叫做服务提供方。")]),v._v(" "),t("p",[v._v("RPC 的核心流程是：")]),v._v(" "),t("ul",[t("li",[v._v("调用方将请求参数序列化成二进制传输给服务提供方")]),v._v(" "),t("li",[v._v("服务提供方将二进制反序列化后，完成方法调用，然后将结果序列化成二进制发送给调用方")])]),v._v(" "),t("p",[v._v("传输可以通过 HTTP 协议，也可以定制 RPC 私有协议，他们都是应用层协议，底层一般都基于 TCP 协议。")]),v._v(" "),t("p",[v._v("序列化/反序列化的方法有很多，各语言都有自带方法序列化为二进制。但事情远没有那么简单，要考虑到性能、压缩率、跨语言、向下兼容、大小端等。所以出现了一些序列化框架：")]),v._v(" "),t("ul",[t("li",[v._v("Protobuf")]),v._v(" "),t("li",[v._v("Hessian")]),v._v(" "),t("li",[v._v("Thrift")]),v._v(" "),t("li",[v._v("Avro")]),v._v(" "),t("li",[v._v("等等")])]),v._v(" "),t("p",[v._v("可以从以下几个角度来决定如何选择序列化框架：")]),v._v(" "),t("ul",[t("li",[v._v("序列化/反序列化的性能")]),v._v(" "),t("li",[v._v("二进制数据的体积大小，这决定了网络传输的效率")]),v._v(" "),t("li",[v._v("向下兼容，当消息格式升级后，旧版本的客户端还需要能正常使用")])])])}),[],!1,null,null,null);_.default=r.exports}}]);