(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{369:function(t,r,a){"use strict";a.r(r);var e=a(43),s=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"最优连续子串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最优连续子串"}},[t._v("#")]),t._v(" 最优连续子串")]),t._v(" "),a("p",[t._v("这些题共同的解题思路：先用for(end)for(start)双循环枚举，然后可以启发出单循环算法（本质是一种动态规划）。注意一般我们会自然而然地写出for(start)for(end)的双循环形式，但这种形式很难启发出单循环算法。")]),t._v(" "),a("p",[t._v("单循环算法是在外层循环中提炼出足够多的“先验知识”，从而无需执行内层循环。“先验知识”可能是简单的number，也可能是复杂的数组、集合等等。")]),t._v(" "),a("p",[t._v("力扣题目（由易到难）：53、152、560、1371、32")]),t._v(" "),a("h2",{attrs:{id:"力扣53-最大子序和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#力扣53-最大子序和"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/maximum-subarray/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣53. 最大子序和"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"力扣152-乘积最大子数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#力扣152-乘积最大子数组"}},[t._v("#")]),t._v(" 力扣152. 乘积最大子数组")]),t._v(" "),a("h2",{attrs:{id:"力扣560-和为k的子数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#力扣560-和为k的子数组"}},[t._v("#")]),t._v(" 力扣560. 和为K的子数组")]),t._v(" "),a("p",[t._v("这题不是找最优子串，而是找出子串的数量，但思路是一样的，所以也归类在这边。\n这题的“先验知识”比较复杂是：累和+字典计数。")]),t._v(" "),a("h2",{attrs:{id:"力扣1371-每个元音包含偶数次的最长子字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#力扣1371-每个元音包含偶数次的最长子字符串"}},[t._v("#")]),t._v(" 力扣1371. 每个元音包含偶数次的最长子字符串")]),t._v(" "),a("p",[t._v("这题的“先验知识”用到了状态压缩的技巧，利用位运算将状态压缩到一个整数中。")]),t._v(" "),a("h2",{attrs:{id:"力扣32-最长有效括号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#力扣32-最长有效括号"}},[t._v("#")]),t._v(" 力扣32. 最长有效括号")]),t._v(" "),a("p",[t._v("这题的“先验知识”是数组，而且每次遍历都需要对“先验知识”进行“统筹优化”，因此比较难。")])])}),[],!1,null,null,null);r.default=s.exports}}]);