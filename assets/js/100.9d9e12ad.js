(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{491:function(t,a,v){"use strict";v.r(a);var s=v(45),_=Object(s.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),v("h2",{attrs:{id:"创建型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建型"}},[t._v("#")]),t._v(" 创建型")]),t._v(" "),v("h3",{attrs:{id:"原型模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[t._v("#")]),t._v(" 原型模式")]),t._v(" "),v("p",[t._v("如果一个对象的创建非常耗费CPU时间；或者需要从外部系统、慢速IO中读取数据；或者其它难以创建的情况。那么可以考虑使用原型模式，直接从已有对象拷贝得到新对象。")]),t._v(" "),v("p",[t._v("在实践中很容易发现哪些场景需要使用原型模式，重点在于：")]),t._v(" "),v("ul",[v("li",[t._v("区分深拷贝/浅拷贝")]),t._v(" "),v("li",[t._v("语言/库是否有内置的深拷贝方法")]),t._v(" "),v("li",[t._v("深拷贝如何处理循环引用的问题")])]),t._v(" "),v("p",[t._v("如果需要手写深拷贝，那么方案有递归复制、序列化两种方法。")]),t._v(" "),v("p",[t._v("深拷贝往往很耗时，为了提升性能。一方面，我们可以结合业务，部分字段浅拷贝，部分字段深拷贝。另一方面，如果是不可变对象，可以大胆使用浅拷贝。")]),t._v(" "),v("h2",{attrs:{id:"代码实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代码实践"}},[t._v("#")]),t._v(" 代码实践")]),t._v(" "),v("h3",{attrs:{id:"深拷贝"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[t._v("#")]),t._v(" 深拷贝")]),t._v(" "),v("p",[t._v("在原型模式中我们介绍了深拷贝，那么应该怎么实现呢？")]),t._v(" "),v("p",[t._v("在 JavaScript 中，我们可以使用 "),v("code",[t._v("JSON.parse()")]),t._v(" 和 "),v("code",[t._v("JSON.stringify()")]),t._v("，但它是有缺点的。我们还可以使用 lodash 提供的库函数 "),v("code",[t._v("_.cloneDeep()")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"mvc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[t._v("#")]),t._v(" MVC")]),t._v(" "),v("h2",{attrs:{id:"组合优于继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组合优于继承"}},[t._v("#")]),t._v(" 组合优于继承")]),t._v(" "),v("p",[t._v("使用继承的话，子类会调用父类的方法，就形成了子类对父类的依赖。父类内部的实现变动，可能会影响到子类。")]),t._v(" "),v("p",[t._v("参考《Effective Java》第四章第16条")])])}),[],!1,null,null,null);a.default=_.exports}}]);