(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{387:function(t,v,a){"use strict";a.r(v);var _=a(43),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"编程语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编程语言"}},[t._v("#")]),t._v(" 编程语言")]),t._v(" "),a("h2",{attrs:{id:"语言理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语言理论"}},[t._v("#")]),t._v(" 语言理论")]),t._v(" "),a("h3",{attrs:{id:"强类型语言和弱类型语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强类型语言和弱类型语言"}},[t._v("#")]),t._v(" 强类型语言和弱类型语言")]),t._v(" "),a("p",[t._v("1974年，Liskov和Zilles提出强类型语言的概念")]),t._v(" "),a("blockquote",[a("p",[t._v("在强类型语言中，当一个对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容")])]),t._v(" "),a("p",[t._v("但是这个解释很泛，也不容易理解，后人给出了更具体的解释：在强类型语言中，变量的类型不能被改变。")]),t._v(" "),a("p",[t._v("例如Java是强类型语言：")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("C")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" z "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" z"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里Java会将'a'的ASCII码传递给x，x的类型仍然是int")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"静态类型语言和动态类型语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态类型语言和动态类型语言"}},[t._v("#")]),t._v(" 静态类型语言和动态类型语言")]),t._v(" "),a("p",[t._v("静态类型语言：在编译阶段确定所有变量的类型")]),t._v(" "),a("p",[t._v("动态类型语言：在运行阶段确定所有变量的类型")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("C")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// js在编译的时候并不知道a和b的类型")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("C")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("C a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" C b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// c++在编译的时候就知道a和b的类型")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("静态类型语言在编译阶段就能够确定属性的偏移量：")]),t._v(" "),a("ul",[a("li",[t._v("编译阶段就确定了属性的偏移量")]),t._v(" "),a("li",[t._v("运行阶段直接根据偏移量来访问")]),t._v(" "),a("li",[t._v("所有对象共享相同的偏移量")])]),t._v(" "),a("p",[t._v("而动态类型语言编译时无法确定属性偏移量：")]),t._v(" "),a("ul",[a("li",[t._v("在运行时才知道偏移量")]),t._v(" "),a("li",[t._v("需要额外空间维护属性名和偏移量之间的映射")]),t._v(" "),a("li",[t._v("每个对象的偏移量都不相同")])]),t._v(" "),a("h2",{attrs:{id:"语言特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语言特性"}},[t._v("#")]),t._v(" 语言特性")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("特性")]),t._v(" "),a("th",[t._v("C++")]),t._v(" "),a("th",[t._v("Java")]),t._v(" "),a("th",[t._v("Py3")]),t._v(" "),a("th",[t._v("ES5")]),t._v(" "),a("th",[t._v("ES6")]),t._v(" "),a("th",[t._v("TS")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("foreach循环")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("foreach遍历Unicode字符串")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("模板字符串")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("模板字符串内嵌表达式")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("-")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("2进制整数字面量")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("类型别名")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")])]),t._v(" "),a("tr",[a("td",[t._v("枚举类型")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td",[t._v("Y")])]),t._v(" "),a("tr",[a("td",[t._v("枚举作用域")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("静态类型：类型推断")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")])]),t._v(" "),a("tr",[a("td",[t._v("内联函数")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("输入输出参数")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("匿名函数（复杂Lambda）")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("Y")])]),t._v(" "),a("tr",[a("td",[t._v("可变参数")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("默认参数")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")])]),t._v(" "),a("tr",[a("td",[t._v("闭包")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("Y")])]),t._v(" "),a("tr",[a("td",[t._v("运算符重载")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td",[t._v("N")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("h3",{attrs:{id:"foreach循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#foreach循环"}},[t._v("#")]),t._v(" foreach循环")]),t._v(" "),a("h3",{attrs:{id:"foreach遍历unicode字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#foreach遍历unicode字符串"}},[t._v("#")]),t._v(" foreach遍历Unicode字符串")]),t._v(" "),a("h3",{attrs:{id:"模板字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板字符串"}},[t._v("#")]),t._v(" 模板字符串")]),t._v(" "),a("h3",{attrs:{id:"模板字符串内嵌表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板字符串内嵌表达式"}},[t._v("#")]),t._v(" 模板字符串内嵌表达式")]),t._v(" "),a("h3",{attrs:{id:"_2进制整数字面量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2进制整数字面量"}},[t._v("#")]),t._v(" 2进制整数字面量")]),t._v(" "),a("h3",{attrs:{id:"类型别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型别名"}},[t._v("#")]),t._v(" 类型别名")]),t._v(" "),a("p",[t._v("类型别名是对类型的一种抽象。")]),t._v(" "),a("p",[t._v("在C中通过typedef为已有类型定义别名："),a("code",[t._v("typedef int ID;")])]),t._v(" "),a("p",[t._v("在C++中使用using："),a("code",[t._v("using ID = int;")])]),t._v(" "),a("p",[t._v("在TypeScript中："),a("code",[t._v("type ID = int;")])]),t._v(" "),a("h3",{attrs:{id:"枚举类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#枚举类型"}},[t._v("#")]),t._v(" 枚举类型")]),t._v(" "),a("p",[t._v("枚举可以创建出一个新的数据类型，它的取值范围以及可执行的操作都会受限。")]),t._v(" "),a("p",[t._v("枚举元素是常量，有默认值（从0开始）")]),t._v(" "),a("p",[t._v("C++："),a("code",[t._v("enum Color { RED, GREEN, YELLOW }")])]),t._v(" "),a("h3",{attrs:{id:"静态类型：类型推断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态类型：类型推断"}},[t._v("#")]),t._v(" 静态类型：类型推断")]),t._v(" "),a("p",[t._v("C++在变量声明的时候可以使用auto关键字："),a("code",[t._v("auto val = val1 + val2;")])]),t._v(" "),a("p",[t._v("C++的decltype更强大，其功能和auto形成互补，可以推断出一个变量的类型："),a("code",[t._v("int foo(decltype(val) arg);")])]),t._v(" "),a("h3",{attrs:{id:"输入输出参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输入输出参数"}},[t._v("#")]),t._v(" 输入输出参数")]),t._v(" "),a("p",[t._v("C可以通过传递指针实现")]),t._v(" "),a("p",[t._v("C++通过引用传递实现")]),t._v(" "),a("p",[t._v("Python因为支持函数多返回值，也不需要支持输入输出参数")]),t._v(" "),a("p",[t._v("题外话：更多时候C++传引用不是为了双向传递，而是避免大对象值传递消耗太多内存，这时使用"),a("code",[t._v("const int *a")]),t._v("可以避免不小心修改实参。")]),t._v(" "),a("h3",{attrs:{id:"匿名函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#匿名函数"}},[t._v("#")]),t._v(" 匿名函数")]),t._v(" "),a("p",[t._v("Python被缩进式语法给坑了，无法支持复杂的Lambda表达式，这也导致Python难以实现函数式编程。")]),t._v(" "),a("h3",{attrs:{id:"可变参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可变参数"}},[t._v("#")]),t._v(" 可变参数")]),t._v(" "),a("h3",{attrs:{id:"默认参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#默认参数"}},[t._v("#")]),t._v(" 默认参数")]),t._v(" "),a("p",[t._v("TS甚至不要求默认参数的位置出现在最后，怎么做到的呢？这得益于JS的"),a("code",[t._v("undefined")]),t._v("的特殊语义，这其实是JS的缺点，但是因祸得福吧。")]),t._v(" "),a("h3",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("h3",{attrs:{id:"运算符重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运算符重载"}},[t._v("#")]),t._v(" 运算符重载")]),t._v(" "),a("p",[t._v("Python支持运算符重载，所以有时判等需要用"),a("code",[t._v("a is b")]),t._v("，而不是用"),a("code",[t._v("a == b")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"面向对象语言特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象语言特性"}},[t._v("#")]),t._v(" 面向对象语言特性")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("特性")]),t._v(" "),a("th",[t._v("C++")]),t._v(" "),a("th",[t._v("Java")]),t._v(" "),a("th",[t._v("Py3")]),t._v(" "),a("th",[t._v("ES5")]),t._v(" "),a("th",[t._v("ES6")]),t._v(" "),a("th",[t._v("TS")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("继承")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("多态")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Y")])]),t._v(" "),a("tr",[a("td",[t._v("虚基类")]),t._v(" "),a("td",[t._v("Y")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td",[t._v("N")]),t._v(" "),a("td",[t._v("Y")])]),t._v(" "),a("tr",[a("td",[t._v("多重继承")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("接口")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("接口继承接口")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("接口继承类")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("h2",{attrs:{id:"编程范式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编程范式"}},[t._v("#")]),t._v(" 编程范式")]),t._v(" "),a("h3",{attrs:{id:"函数式编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[t._v("#")]),t._v(" 函数式编程")]),t._v(" "),a("ul",[a("li",[t._v("实现一个memorize函数，加快汉诺塔算法、斐波那契数列算法")]),t._v(" "),a("li",[t._v("实现函数防抖、函数节流")])]),t._v(" "),a("h2",{attrs:{id:"语言实现细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语言实现细节"}},[t._v("#")]),t._v(" 语言实现细节")]),t._v(" "),a("h3",{attrs:{id:"参数传递"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数传递"}},[t._v("#")]),t._v(" 参数传递")]),t._v(" "),a("p",[t._v("Python中，函数参数只有引用传递，没有值传递，那么参数传int的时候不怕函数修改实参吗？")]),t._v(" "),a("h3",{attrs:{id:"多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[t._v("#")]),t._v(" 多线程")]),t._v(" "),a("p",[t._v("Python有多种实现，其官方实现的多线程能力很差，因为Python有一个全局解释器锁，导致每一行Python代码都是竞争资源。")])])}),[],!1,null,null,null);v.default=s.exports}}]);